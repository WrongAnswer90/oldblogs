{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u8fd9\u91cc\u662f WA90 \u7684\u4ee3\u7801\u4ed3\u5e93\uff0c\u90e8\u5206\u6a21\u677f\u9700\u8981\u642d\u914d \u7f3a\u7701\u6e90 \u4f7f\u7528 QQ\uff1a2609493041 \u6b22\u8fce\u8054\u7cfb\u3002","title":"Home"},{"location":"DS/FHQ/","text":"abababababa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 struct Node { int l , r , size , rd , val , tag ;} fhq [ 200001 ]; int n , cnt , m , root ; inline void update ( int x ){ fhq [ x ]. size = fhq [ fhq [ x ]. l ]. size + fhq [ fhq [ x ]. r ]. size + 1 ;} inline int newnode ( int val ){ fhq [ ++ cnt ]. val = val , fhq [ cnt ]. rd = rand () % 11451419 , fhq [ cnt ]. size = 1 ; return cnt ;} inline void spread ( int x ) { if ( fhq [ x ]. tag ) { swap ( fhq [ x ]. l , fhq [ x ]. r ); fhq [ fhq [ x ]. l ]. tag ^= 1 , fhq [ fhq [ x ]. r ]. tag ^= 1 ; fhq [ x ]. tag = 0 ; } } void split ( int now , int rank , int & x , int & y ) { if ( ! now ){ x = y = 0 ; return ;} spread ( now ); if ( fhq [ fhq [ now ]. l ]. size >= rank ) y = now , split ( fhq [ now ]. l , rank , x , fhq [ now ]. l ); else x = now , split ( fhq [ now ]. r , rank - fhq [ fhq [ now ]. l ]. size -1 , fhq [ now ]. r , y ); update ( now ); } int merge ( int x , int y ) { if ( ! x ||! y ) return x + y ; if ( fhq [ x ]. rd > fhq [ y ]. rd ){ spread ( x ), fhq [ x ]. r = merge ( fhq [ x ]. r , y ), update ( x ); return x ;} else { spread ( y ), fhq [ y ]. l = merge ( x , fhq [ y ]. l ), update ( y ); return y ;} }","title":"fhq treap"},{"location":"DS/KDT/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 struct Node { int v , sum , ls , rs , x [ 2 ], L [ 2 ], R [ 2 ]; Node ( int X = 0 , int Y = 0 , int Z = 0 ){ x [ 0 ] = X , x [ 1 ] = Y , v = Z ;}} t [ 200010 ], l , r ; int ans , n , cnt , root [ 18 ], b [ 200010 ]; #define ls(x) t[x].ls #define rs(x) t[x].rs inline void update ( int p ) { t [ p ]. sum = t [ ls ( p )]. sum + t [ rs ( p )]. sum + t [ p ]. v ; for ( int k = 0 ; k < 2 ; ++ k ) { t [ p ]. L [ k ] = t [ p ]. R [ k ] = t [ p ]. x [ k ]; if ( ls ( p )) Mmin ( t [ p ]. L [ k ], t [ ls ( p )]. L [ k ]), Mmax ( t [ p ]. R [ k ], t [ ls ( p )]. R [ k ]); if ( rs ( p )) Mmin ( t [ p ]. L [ k ], t [ rs ( p )]. L [ k ]), Mmax ( t [ p ]. R [ k ], t [ rs ( p )]. R [ k ]); } } inline bool cmpx ( int x , int y ){ return t [ x ]. x [ 0 ] < t [ y ]. x [ 0 ];} inline bool cmpy ( int x , int y ){ return t [ x ]. x [ 1 ] < t [ y ]. x [ 1 ];} int build ( int l , int r , int dep = 0 ) { int mid = l + (( r - l ) >> 1 ); nth_element ( b + l , b + mid , b + r + 1 , dep ? cmpx : cmpy ); int x = b [ mid ]; if ( l < mid ) ls ( x ) = build ( l , mid -1 , dep ^ 1 ); if ( mid < r ) rs ( x ) = build ( mid + 1 , r , dep ^ 1 ); return update ( x ), x ; } void append ( int & p ){ if ( p ) b [ ++ cnt ] = p , append ( ls ( p )), append ( rs ( p )), p = 0 ;} int query ( int p ) { if ( ! p ) return 0 ; bool flag = 1 ; for ( int k = 0 ; k < 2 ; ++ k ) flag &= l . x [ k ] <= t [ p ]. L [ k ] && r . x [ k ] >= t [ p ]. R [ k ]; if ( flag ) return t [ p ]. sum ; for ( int k = 0 ; k < 2 ; ++ k ) if ( t [ p ]. R [ k ] < l . x [ k ] || t [ p ]. L [ k ] > r . x [ k ]) return 0 ; flag = 1 ; for ( int k = 0 ; k < 2 ; ++ k ) flag &= l . x [ k ] <= t [ p ]. x [ k ] && r . x [ k ] >= t [ p ]. x [ k ]; return flag * t [ p ]. v + query ( ls ( p )) + query ( rs ( p )); } inline void ins ( int x , int y , int z ) { t [ ++ n ] = Node ( x , y , z ), b [ cnt = 1 ] = n ; for ( int i = 0 ;; ++ i ) { if ( ! root [ i ]){ root [ i ] = build ( 1 , cnt ); break ;} else append ( root [ i ]); } }","title":"K-D tree"},{"location":"DS/LCT/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 namespace Splay { struct { int fa , ch [ 2 ], val , siz , sum ; bool tag ;} spl [ 1000001 ]; #define ls(x) (spl[x].ch[0]) #define rs(x) (spl[x].ch[1]) #define fa(x) (spl[x].fa) #define ident(x,f) (rs(f)==x) #define connect(x,f,s) (spl[fa(x)=f].ch[s]=x) #define update(x) (spl[x].siz=spl[ls(x)].siz+spl[rs(x)].siz+1,spl[x].sum=spl[ls(x)].sum^spl[rs(x)].sum^spl[x].val) #define ntroot(x) ((ls(fa(x))==x)||(rs(fa(x))==x)) #define down(x) (swap(ls(x),rs(x)),spl[x].tag^=1) inline void spread ( int k ) { if ( spl [ k ]. tag ) down ( ls ( k )), down ( rs ( k )); spl [ k ]. tag = 0 ; } void pushall ( int x ){ if ( ntroot ( x )) pushall ( fa ( x )); spread ( x );} inline void rotate ( int x ) { int f = fa ( x ), ff = fa ( f ), s = ident ( x , f ); if ( ntroot ( f )) spl [ ff ]. ch [ ident ( f , ff )] = x ; connect ( spl [ x ]. ch [ s ^ 1 ], f , s ), fa ( x ) = ff , connect ( f , x , s ^ 1 ), update ( f ), update ( x ); } inline void splaying ( int x ) { pushall ( x ); while ( ntroot ( x )) { int f = fa ( x ), ff = fa ( f ); if ( ntroot ( f ))( ident ( x , f ) ^ ident ( f , ff )) ? rotate ( x ) : rotate ( f ); rotate ( x ); } } } using namespace Splay ; inline void access ( int x ){ for ( int y = 0 ; x ; x = fa ( y = x )) splaying ( x ), rs ( x ) = y , update ( x );} inline void mkroot ( int x ){ access ( x ), splaying ( x ), down ( x );} inline int findroot ( int x ) { access ( x ), splaying ( x ), spread ( x ); while ( ls ( x )) x = ls ( x ), spread ( x ); splaying ( x ); return x ; } inline void link ( int x , int y ) { mkroot ( x ); if ( findroot ( y ) == x ) return ; fa ( x ) = y ; } inline void cut ( int x , int y ) { mkroot ( x ); if ( findroot ( y ) != x || fa ( y ) != x || ls ( y )) return ; fa ( y ) = rs ( x ) = 0 , update ( x ); } inline void split ( int x , int y ){ mkroot ( x ), access ( y ), splaying ( y );}","title":"\u52a8\u6001\u6811"},{"location":"DS/LTT/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 struct { int l , r , fa , val , dis ;} t [ 300001 ]; int find ( int x ){ return x == t [ x ]. fa ? x : t [ x ]. fa = find ( t [ x ]. fa );} int merge ( int x , int y ) { if ( ! x ||! y ) return x | y ; if ( t [ x ]. val > t [ y ]. val || ( t [ x ]. val == t [ y ]. val && x > y )) swap ( x , y ); t [ x ]. r = merge ( t [ x ]. r , y ); t [ t [ x ]. r ]. fa = x ; if ( t [ t [ x ]. l ]. dis < t [ t [ x ]. r ]. dis ) swap ( t [ x ]. l , t [ x ]. r ); t [ x ]. dis = t [ t [ x ]. r ]. dis + 1 ; return x ; } inline void pop ( int x ){ t [ x ]. val = -1 , t [ t [ x ]. l ]. fa = t [ t [ x ]. r ]. fa = t [ x ]. fa = t [ x ]. l = merge ( t [ x ]. l , t [ x ]. r );}","title":"\u53ef\u5e76\u5806"},{"location":"DS/LiCT/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 struct { double k , b ;} p [ 600001 ]; struct { int l , r , best ;} t [ 800001 ]; int cnt ; inline int cmp ( double x , double y ){ return x - y > eps ? 1 : y - x > eps ? -1 : 0 ;} inline double calc ( int id , int x ){ return x * p [ id ]. k + p [ id ]. b ;} void build ( int p , int l , int r ) { t [ p ]. l = l , t [ p ]. r = r ; if ( l == r ) return ; int mid = l + (( r - l ) >> 1 ); build ( p * 2 , l , mid ), build ( p * 2 + 1 , mid + 1 , r ); } inline void add ( int x0 , int y0 , int x1 , int y1 ) { if ( x0 == x1 ) ++ cnt , p [ cnt ]. k = 0 , p [ cnt ]. b = max ( y0 , y1 ); else ++ cnt , p [ cnt ]. k = 1.0 * ( y0 - y1 ) / ( x0 - x1 ), p [ cnt ]. b = ( double ) y0 - ( double ) x0 * p [ cnt ]. k ; } void update ( int p , int u ) { int & v = t [ p ]. best ; int mid = t [ p ]. l + t [ p ]. r >> 1 ; int dl = cmp ( calc ( u , mid ), calc ( v , mid )); if ( dl == 1 || ( dl == 0 && u < v )) swap ( u , v ); int bl = cmp ( calc ( u , t [ p ]. l ), calc ( v , t [ p ]. l )), br = cmp ( calc ( u , t [ p ]. r ), calc ( v , t [ p ]. r )); if ( bl == 1 || ( bl == 0 && u < v )) update ( p * 2 , u ); if ( br == 1 || ( br == 0 && u < v )) update ( p * 2 + 1 , u ); } void modify ( int p , int l , int r , int k ) { if ( l <= t [ p ]. l && r >= t [ p ]. r ) return update ( p , k ); if ( l <= t [ p * 2 ]. r ) modify ( p * 2 , l , r , k ); if ( r > t [ p * 2 ]. r ) modify ( p * 2 + 1 , l , r , k ); } pdi maxx ( pdi p1 , pdi p2 ) { if ( cmp ( p1 . fi , p2 . fi ) == 1 ) return p1 ; if ( cmp ( p1 . fi , p2 . fi ) == -1 ) return p2 ; return p1 . se < p2 . se ? p1 : p2 ; } pdi ask ( int p , int k ) { if ( t [ p ]. l == t [ p ]. r ) return mp ( calc ( t [ p ]. best , k ), t [ p ]. best ); pdi res = mp ( calc ( t [ p ]. best , k ), t [ p ]. best ); if ( k <= t [ p * 2 ]. r ) return maxx ( res , ask ( p * 2 , k )); return maxx ( res , ask ( p * 2 + 1 , k )); }","title":"\u674e\u8d85\u6811"},{"location":"DS/Segment/","text":"Without Tag 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 template < class Info > struct Segment { #define ls(p) (t[p].l+t[p].r) #define rs(p) (ls(p)^1) private : vector < Info > tmp ; struct { int l , r ; Info v ;} t [ N << 1 ]; void build ( int p , int l , int r ) { t [ p ]. l = l , t [ p ]. r = r ; if ( l == r ) return t [ p ]. v = tmp [ l -1 ], void (); int mid = ( l + r ) >> 1 ; build ( ls ( p ), l , mid ), build ( rs ( p ), mid + 1 , r ); t [ p ]. v = t [ ls ( p )]. v + t [ rs ( p )]. v ; } public : void change ( int p , int x , Info v ) { if ( t [ p ]. l == t [ p ]. r ) return t [ p ]. v = v , void (); change ( ls ( p ) ^ ( x > t [ ls ( p )]. r ), x , v ); t [ p ]. v = t [ ls ( p )]. v + t [ rs ( p )]. v ; } Info ask ( int p , int l , int r ) { if ( l <= t [ p ]. l && r >= t [ p ]. r ) return t [ p ]. v ; if ( r <= t [ ls ( p )]. r ) return ask ( ls ( p ), l , r ); if ( l > t [ ls ( p )]. r ) return ask ( rs ( p ), l , r ); return ask ( ls ( p ), l , r ) + ask ( rs ( p ), l , r ); } template < class Compare > pair < int , Info > findnex ( int p , int x , Info y , Compare cmp ) { if ( x > t [ p ]. r ||! cmp ( y , t [ p ]. v )) return mp ( 0 ,( Info ){}); if ( t [ p ]. l == t [ p ]. r ) return mp ( t [ p ]. l , t [ p ]. v ); pair < int , Info > v = findnex ( ls ( p ), x , y , cmp ); if ( v . fi ) return v ; return findnex ( rs ( p ), x , y , cmp ); } template < class Compare > pair < int , Info > findpre ( int p , int x , Info y , Compare cmp ) { if ( x < t [ p ]. l ||! cmp ( y , t [ p ]. v )) return mp ( 0 ,( Info ){}); if ( t [ p ]. l == t [ p ]. r ) return mp ( t [ p ]. l , t [ p ]. v ); pair < int , Info > v = findpre ( rs ( p ), x , y , cmp ); if ( v . fi ) return v ; return findpre ( ls ( p ), x , y , cmp ); } void print ( int p = 1 ) { if ( t [ p ]. l == t [ p ]. r ) return t [ p ]. v . print (); print ( ls ( p )), print ( rs ( p )); } template < class Compare > pair < int , Info > findnex ( int x , Info y , Compare cmp ) { return findnex ( 1 , x , y , cmp );} template < class Compare > pair < int , Info > findpre ( int x , Info y , Compare cmp ) { return findpre ( 1 , x , y , cmp );} void change ( int x , Info v ){ change ( 1 , x , v );} Info ask ( int l , int r ){ return ask ( 1 , l , r );} void init ( vector < Info > ve ){ tmp = ve , build ( 1 , 1 , ve . size ());} #undef ls #undef rs }; struct Node { //... Node (){} Node operator + ( const Node nd ) const { //... } void print () { //... } }; With Tag 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 template < class Info , class Tag > struct Segment { #define ls(p) (t[p].l+t[p].r) #define rs(p) (ls(p)^1) private : vector < Info > tmp ; struct { int l , r ; Info v ; Tag tg ;} t [ N << 1 ]; inline void down ( int p , Tag tg ){ t [ p ]. v = t [ p ]. v * tg , t [ p ]. tg = t [ p ]. tg * tg ;} inline void spread ( int p ){ down ( ls ( p ), t [ p ]. tg ), down ( rs ( p ), t [ p ]. tg ), t [ p ]. tg = Tag ();} void build ( int p , int l , int r ) { t [ p ]. l = l , t [ p ]. r = r ; if ( l == r ) return t [ p ]. v = tmp [ l -1 ], void (); int mid = l + (( r - l ) >> 1 ); build ( ls ( p ), l , mid ), build ( rs ( p ), mid + 1 , r ); t [ p ]. v = t [ ls ( p )]. v + t [ rs ( p )]. v ; } void change ( int p , int x , Info v ) { if ( t [ p ]. l == t [ p ]. r ) return t [ p ]. v = v , void (); spread ( p ); change ( ls ( p ) ^ ( x > t [ ls ( p )]. r ), x , v ); t [ p ]. v = t [ ls ( p )]. v + t [ rs ( p )]. v ; } Info ask ( int p , int l , int r ) { if ( l <= t [ p ]. l && r >= t [ p ]. r ) return t [ p ]. v ; spread ( p ); if ( r <= t [ ls ( p )]. r ) return ask ( ls ( p ), l , r ); if ( l > t [ ls ( p )]. r ) return ask ( rs ( p ), l , r ); return ask ( ls ( p ), l , r ) + ask ( rs ( p ), l , r ); } void modify ( int p , int l , int r , Tag tg ) { if ( l <= t [ p ]. l && r >= t [ p ]. r ) return down ( p , tg ); spread ( p ); if ( l <= t [ ls ( p )]. r ) modify ( ls ( p ), l , r , tg ); if ( r > t [ ls ( p )]. r ) modify ( rs ( p ), l , r , tg ); t [ p ]. v = t [ ls ( p )]. v + t [ rs ( p )]. v ; } template < class Compare > pair < int , Info > findnex ( int p , int x , Info y , Compare cmp ) { if ( x > t [ p ]. r ||! cmp ( y , t [ p ]. v )) return mp ( 0 ,( Info ){}); if ( t [ p ]. l == t [ p ]. r ) return mp ( t [ p ]. l , t [ p ]. v ); spread ( p ); pair < int , Info > v = findnex ( ls ( p ), x , y , cmp ); if ( v . fi ) return v ; return findnex ( rs ( p ), x , y , cmp ); } template < class Compare > pair < int , Info > findpre ( int p , int x , Info y , Compare cmp ) { if ( x < t [ p ]. l ||! cmp ( y , t [ p ]. v )) return mp ( 0 ,( Info ){}); if ( t [ p ]. l == t [ p ]. r ) return mp ( t [ p ]. l , t [ p ]. v ); spread ( p ); pair < int , Info > v = findpre ( rs ( p ), x , y , cmp ); if ( v . fi ) return v ; return findpre ( ls ( p ), x , y , cmp ); } public : void print ( int p = 1 ) { if ( t [ p ]. l == t [ p ]. r ) return t [ p ]. v . print (); spread ( p ), print ( ls ( p )), print ( rs ( p )); } void printall ( int p = 1 ) { write ( '[' , t [ p ]. l , ',' , t [ p ]. r , ']' , ':' ); t [ p ]. v . print (); spread ( p ), print ( ls ( p )), print ( rs ( p )); } void modify ( int l , int r , Tag tg ){ modify ( 1 , l , r , tg );} template < class Compare > pair < int , Info > findnex ( int x , Info y , Compare cmp ) { return findnex ( 1 , x , y , cmp );} template < class Compare > pair < int , Info > findpre ( int x , Info y , Compare cmp ) { return findpre ( 1 , x , y , cmp );} void change ( int x , Info v ){ change ( 1 , x , v );} Info ask ( int l , int r ){ return ask ( 1 , l , r );} void init ( vector < Info > ve ){ tmp = ve , build ( 1 , 1 , ve . size ());} #undef ls #undef rs }; struct Tag { //... Tag (){} Tag operator * ( const Tag nd ) const { Tag v ; //... return v ; } }; struct Node { //... Node (){} Node operator + ( const Node nd ) const { Node v ; //... return v ; } Node operator * ( const Tag nd ) const { Node v ; //... return v ; } void print () { //... } };","title":"\u7ebf\u6bb5\u6811"},{"location":"DS/Segment/#without-tag","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 template < class Info > struct Segment { #define ls(p) (t[p].l+t[p].r) #define rs(p) (ls(p)^1) private : vector < Info > tmp ; struct { int l , r ; Info v ;} t [ N << 1 ]; void build ( int p , int l , int r ) { t [ p ]. l = l , t [ p ]. r = r ; if ( l == r ) return t [ p ]. v = tmp [ l -1 ], void (); int mid = ( l + r ) >> 1 ; build ( ls ( p ), l , mid ), build ( rs ( p ), mid + 1 , r ); t [ p ]. v = t [ ls ( p )]. v + t [ rs ( p )]. v ; } public : void change ( int p , int x , Info v ) { if ( t [ p ]. l == t [ p ]. r ) return t [ p ]. v = v , void (); change ( ls ( p ) ^ ( x > t [ ls ( p )]. r ), x , v ); t [ p ]. v = t [ ls ( p )]. v + t [ rs ( p )]. v ; } Info ask ( int p , int l , int r ) { if ( l <= t [ p ]. l && r >= t [ p ]. r ) return t [ p ]. v ; if ( r <= t [ ls ( p )]. r ) return ask ( ls ( p ), l , r ); if ( l > t [ ls ( p )]. r ) return ask ( rs ( p ), l , r ); return ask ( ls ( p ), l , r ) + ask ( rs ( p ), l , r ); } template < class Compare > pair < int , Info > findnex ( int p , int x , Info y , Compare cmp ) { if ( x > t [ p ]. r ||! cmp ( y , t [ p ]. v )) return mp ( 0 ,( Info ){}); if ( t [ p ]. l == t [ p ]. r ) return mp ( t [ p ]. l , t [ p ]. v ); pair < int , Info > v = findnex ( ls ( p ), x , y , cmp ); if ( v . fi ) return v ; return findnex ( rs ( p ), x , y , cmp ); } template < class Compare > pair < int , Info > findpre ( int p , int x , Info y , Compare cmp ) { if ( x < t [ p ]. l ||! cmp ( y , t [ p ]. v )) return mp ( 0 ,( Info ){}); if ( t [ p ]. l == t [ p ]. r ) return mp ( t [ p ]. l , t [ p ]. v ); pair < int , Info > v = findpre ( rs ( p ), x , y , cmp ); if ( v . fi ) return v ; return findpre ( ls ( p ), x , y , cmp ); } void print ( int p = 1 ) { if ( t [ p ]. l == t [ p ]. r ) return t [ p ]. v . print (); print ( ls ( p )), print ( rs ( p )); } template < class Compare > pair < int , Info > findnex ( int x , Info y , Compare cmp ) { return findnex ( 1 , x , y , cmp );} template < class Compare > pair < int , Info > findpre ( int x , Info y , Compare cmp ) { return findpre ( 1 , x , y , cmp );} void change ( int x , Info v ){ change ( 1 , x , v );} Info ask ( int l , int r ){ return ask ( 1 , l , r );} void init ( vector < Info > ve ){ tmp = ve , build ( 1 , 1 , ve . size ());} #undef ls #undef rs }; struct Node { //... Node (){} Node operator + ( const Node nd ) const { //... } void print () { //... } };","title":"Without Tag"},{"location":"DS/Segment/#with-tag","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 template < class Info , class Tag > struct Segment { #define ls(p) (t[p].l+t[p].r) #define rs(p) (ls(p)^1) private : vector < Info > tmp ; struct { int l , r ; Info v ; Tag tg ;} t [ N << 1 ]; inline void down ( int p , Tag tg ){ t [ p ]. v = t [ p ]. v * tg , t [ p ]. tg = t [ p ]. tg * tg ;} inline void spread ( int p ){ down ( ls ( p ), t [ p ]. tg ), down ( rs ( p ), t [ p ]. tg ), t [ p ]. tg = Tag ();} void build ( int p , int l , int r ) { t [ p ]. l = l , t [ p ]. r = r ; if ( l == r ) return t [ p ]. v = tmp [ l -1 ], void (); int mid = l + (( r - l ) >> 1 ); build ( ls ( p ), l , mid ), build ( rs ( p ), mid + 1 , r ); t [ p ]. v = t [ ls ( p )]. v + t [ rs ( p )]. v ; } void change ( int p , int x , Info v ) { if ( t [ p ]. l == t [ p ]. r ) return t [ p ]. v = v , void (); spread ( p ); change ( ls ( p ) ^ ( x > t [ ls ( p )]. r ), x , v ); t [ p ]. v = t [ ls ( p )]. v + t [ rs ( p )]. v ; } Info ask ( int p , int l , int r ) { if ( l <= t [ p ]. l && r >= t [ p ]. r ) return t [ p ]. v ; spread ( p ); if ( r <= t [ ls ( p )]. r ) return ask ( ls ( p ), l , r ); if ( l > t [ ls ( p )]. r ) return ask ( rs ( p ), l , r ); return ask ( ls ( p ), l , r ) + ask ( rs ( p ), l , r ); } void modify ( int p , int l , int r , Tag tg ) { if ( l <= t [ p ]. l && r >= t [ p ]. r ) return down ( p , tg ); spread ( p ); if ( l <= t [ ls ( p )]. r ) modify ( ls ( p ), l , r , tg ); if ( r > t [ ls ( p )]. r ) modify ( rs ( p ), l , r , tg ); t [ p ]. v = t [ ls ( p )]. v + t [ rs ( p )]. v ; } template < class Compare > pair < int , Info > findnex ( int p , int x , Info y , Compare cmp ) { if ( x > t [ p ]. r ||! cmp ( y , t [ p ]. v )) return mp ( 0 ,( Info ){}); if ( t [ p ]. l == t [ p ]. r ) return mp ( t [ p ]. l , t [ p ]. v ); spread ( p ); pair < int , Info > v = findnex ( ls ( p ), x , y , cmp ); if ( v . fi ) return v ; return findnex ( rs ( p ), x , y , cmp ); } template < class Compare > pair < int , Info > findpre ( int p , int x , Info y , Compare cmp ) { if ( x < t [ p ]. l ||! cmp ( y , t [ p ]. v )) return mp ( 0 ,( Info ){}); if ( t [ p ]. l == t [ p ]. r ) return mp ( t [ p ]. l , t [ p ]. v ); spread ( p ); pair < int , Info > v = findpre ( rs ( p ), x , y , cmp ); if ( v . fi ) return v ; return findpre ( ls ( p ), x , y , cmp ); } public : void print ( int p = 1 ) { if ( t [ p ]. l == t [ p ]. r ) return t [ p ]. v . print (); spread ( p ), print ( ls ( p )), print ( rs ( p )); } void printall ( int p = 1 ) { write ( '[' , t [ p ]. l , ',' , t [ p ]. r , ']' , ':' ); t [ p ]. v . print (); spread ( p ), print ( ls ( p )), print ( rs ( p )); } void modify ( int l , int r , Tag tg ){ modify ( 1 , l , r , tg );} template < class Compare > pair < int , Info > findnex ( int x , Info y , Compare cmp ) { return findnex ( 1 , x , y , cmp );} template < class Compare > pair < int , Info > findpre ( int x , Info y , Compare cmp ) { return findpre ( 1 , x , y , cmp );} void change ( int x , Info v ){ change ( 1 , x , v );} Info ask ( int l , int r ){ return ask ( 1 , l , r );} void init ( vector < Info > ve ){ tmp = ve , build ( 1 , 1 , ve . size ());} #undef ls #undef rs }; struct Tag { //... Tag (){} Tag operator * ( const Tag nd ) const { Tag v ; //... return v ; } }; struct Node { //... Node (){} Node operator + ( const Node nd ) const { Node v ; //... return v ; } Node operator * ( const Tag nd ) const { Node v ; //... return v ; } void print () { //... } };","title":"With Tag"},{"location":"DS/Splay/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 struct { int fa , ch [ 2 ], val , siz , sum ; bool tag ;} spl [ 1000001 ]; #define ls(x) (spl[x].ch[0]) #define rs(x) (spl[x].ch[1]) #define fa(x) (spl[x].fa) #define ident(x,f) (rs(f)==x) #define connect(x,f,s) (spl[fa(x)=f].ch[s]=x) #define update(x) (spl[x].siz=spl[ls(x)].siz+spl[rs(x)].siz+1,spl[x].sum=spl[ls(x)].sum^spl[rs(x)].sum^spl[x].val) #define down(x) (swap(ls(x),rs(x)),spl[x].tag^=1) inline void spread ( int k ) { if ( spl [ k ]. tag ) down ( ls ( k )), down ( rs ( k )); spl [ k ]. tag = 0 ; } inline void rotate ( int x ) { int f = fa ( x ), ff = fa ( f ), s = ident ( x , f ); connect ( spl [ x ]. ch [ s ^ 1 ], f , s ), connecf ( x , ff , ident ( f , ff )); connect ( f , x , s ^ 1 ), update ( f ), update ( x ); } inline void splaying ( int x ) { while ( fa ( x )) { int f = fa ( x ), ff = fa ( f ); if ( fa ( f ))( ident ( x , f ) ^ ident ( f , ff )) ? rotate ( x ) : rotate ( f ); rotate ( x ); } }","title":"Splay"},{"location":"DS/exFHQ/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 struct Node { int l , r , siz , rd ; bool tag ; long long val , sum ;} fhq [ 20000001 ]; int cnt , n , root [ 300001 ]; long long lastans = 0 ; inline void update ( int x ) { fhq [ x ]. siz = fhq [ fhq [ x ]. l ]. siz + fhq [ fhq [ x ]. r ]. siz + 1 ; fhq [ x ]. sum = fhq [ fhq [ x ]. l ]. sum + fhq [ fhq [ x ]. r ]. sum + fhq [ x ]. val ; } inline int newnode ( long long val ){ fhq [ ++ cnt ]. val = val , fhq [ cnt ]. siz = 1 , fhq [ cnt ]. sum = val , fhq [ cnt ]. rd = rand () % 114514191 ; return cnt ;} inline int copy ( int x ){ fhq [ ++ cnt ] = fhq [ x ]; return cnt ;} inline void spread ( int x ) { if ( fhq [ x ]. tag ) { if ( fhq [ x ]. l ) fhq [ x ]. l = copy ( fhq [ x ]. l ); if ( fhq [ x ]. r ) fhq [ x ]. r = copy ( fhq [ x ]. r ); swap ( fhq [ x ]. l , fhq [ x ]. r ); if ( fhq [ x ]. l ) fhq [ fhq [ x ]. l ]. tag ^= 1 ; if ( fhq [ x ]. r ) fhq [ fhq [ x ]. r ]. tag ^= 1 ; fhq [ x ]. tag = 0 ; } } void split ( int now , int siz , int & x , int & y ) { if ( ! now ){ x = y = 0 ; return ;} spread ( now ); if ( fhq [ fhq [ now ]. l ]. siz + 1 <= siz ) x = copy ( now ), split ( fhq [ x ]. r , siz - fhq [ fhq [ x ]. l ]. siz -1 , fhq [ x ]. r , y ), update ( x ); else y = copy ( now ), split ( fhq [ y ]. l , siz , x , fhq [ y ]. l ), update ( y ); } int merge ( int x , int y ) { if ( ! x ||! y ) return x + y ; spread ( x ), spread ( y ); if ( fhq [ x ]. rd < fhq [ y ]. rd ){ fhq [ x ]. r = merge ( fhq [ x ]. r , y ), update ( x ); return x ;} fhq [ y ]. l = merge ( x , fhq [ y ]. l ), update ( y ); return y ; }","title":"\u53ef\u6301\u4e45\u5316\u5e73\u8861\u6811"},{"location":"Graph/KM/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 int t [ 501 ][ 501 ]; int n , m , match [ 501 ], pre [ 501 ]; ll ex [ 501 ], ey [ 501 ], vy [ 501 ], slack [ 501 ]; void bfs ( int k ) { ll x , y = 0 , yy = 0 , delta ; memset ( pre , 0 , sizeof ( pre )), memset ( slack , 127 , sizeof ( slack )), match [ y ] = k ; while ( 1 ) { x = match [ y ]; delta = INF , vy [ y ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( vy [ i ]) continue ; if ( slack [ i ] > ex [ x ] + ey [ i ] - t [ x ][ i ]) slack [ i ] = ex [ x ] + ey [ i ] - t [ x ][ i ], pre [ i ] = y ; if ( slack [ i ] < delta ) delta = slack [ i ], yy = i ; } for ( int i = 0 ; i <= n ; ++ i ) { if ( vy [ i ]) ex [ match [ i ]] -= delta , ey [ i ] += delta ; else slack [ i ] -= delta ; } y = yy ; if ( match [ y ] == -1 ) break ; } while ( y ){ match [ y ] = match [ pre [ y ]], y = pre [ y ];} } ll KM () { memset ( match , -1 , sizeof ( match )), memset ( ex , 0 , sizeof ( ex )), memset ( ey , 0 , sizeof ( ey )); for ( int i = 1 ; i <= n ; ++ i ) memset ( vy , 0 , sizeof ( vy )), bfs ( i ); ll res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) if ( match [ i ] != -1 ) res += t [ match [ i ]][ i ]; return res ; }","title":"KM \u7b97\u6cd5"},{"location":"Graph/LCA/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int n , m , rt , tot , cnt , dfn [ 500010 ], head [ 500010 ], to [ 1000010 ], nex [ 1000010 ]; inline void add ( int x , int y ){ to [ ++ cnt ] = y , nex [ cnt ] = head [ x ], head [ x ] = cnt ;} int F [ 19 ][ 500010 ]; inline int get ( int x , int y ){ return dfn [ x ] < dfn [ y ] ? x : y ;} void dfs ( int x , int fa ) { F [ 0 ][ dfn [ x ] =++ tot ] = fa ; for ( int i = head [ x ]; i ; i = nex [ i ]) if ( to [ i ] != fa ) dfs ( to [ i ], x ); } inline int LCA ( int x , int y ) { if ( x == y ) return x ; if (( x = dfn [ x ]) > ( y = dfn [ y ])) swap ( x , y ); int k = __lg ( y - x ++ ); return get ( F [ k ][ x ], F [ k ][ y - ( 1 << k ) + 1 ]); } inline void build () { dfs ( rt , 0 ); for ( int i = 1 ; i < 19 ; ++ i ) { for ( int j = 1 ; j + ( 1 << i ) -1 <= n ; ++ j ) F [ i ][ j ] = get ( F [ i -1 ][ j ], F [ i -1 ][ j + ( 1 << ( i -1 ))]); } }","title":"dfs \u5e8f LCA"},{"location":"Graph/connection/","text":"\u8fb9\u53cc\u8054\u901a\u5206\u91cf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int n , m , cnt = 1 , num , col , low [ 500001 ], dfn [ 500001 ], head [ 500001 ], to [ 4000001 ], nex [ 4000001 ]; inline void add ( int x , int y ){ to [ ++ cnt ] = y , nex [ cnt ] = head [ x ], head [ x ] = cnt ;} stack < int > st ; vector < int > ve [ 500001 ]; void tarjan ( int k , int fromi ) { dfn [ k ] = low [ k ] =++ num , st . e ( k ); for ( int i = head [ k ]; i ; i = nex [ i ]) { if ( i == ( fromi ^ 1 )) continue ; if ( ! dfn [ to [ i ]]) tarjan ( to [ i ], i ), low [ k ] = min ( low [ k ], low [ to [ i ]]); else low [ k ] = min ( low [ k ], dfn [ to [ i ]]); } if ( low [ k ] == dfn [ k ]) { int y ; ++ col ; do ve [ col ]. eb ( y = st . top ()), st . pop (); while ( y != k ); } } \u5f3a\u8054\u901a\u5206\u91cf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int n , m , cnt , num , col , f [ 10001 ], deg [ 10001 ], c [ 10001 ], dfn [ 10001 ], low [ 10001 ], ins [ 10001 ], x [ 100001 ], y [ 100001 ], head [ 10001 ], to [ 100001 ], nex [ 100001 ]; inline void add ( int x , int y ){ to [ ++ cnt ] = y , nex [ cnt ] = head [ x ], head [ x ] = cnt ;} stack < int > st ; queue < int > q ; void tarjan ( int k ) { st . e ( k ), ins [ k ] = 1 , dfn [ k ] = low [ k ] =++ num ; for ( int i = head [ k ]; i ; i = nex [ i ]) { if ( ! dfn [ to [ i ]]) tarjan ( to [ i ]), low [ k ] = min ( low [ k ], low [ to [ i ]]); else if ( ins [ to [ i ]]) low [ k ] = min ( low [ k ], dfn [ to [ i ]]); } if ( dfn [ k ] == low [ k ]) { int y ; ++ col ; do c [ y = st . top ()] = col , ins [ y ] = 0 , st . pop (); while ( y != k ); } } \u5e7f\u4e49\u5706\u65b9\u6811 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int n , m , q , cnt , tot , num , x [ 200001 ], y [ 200001 ], low [ 40001 ], dfn [ 40001 ], head [ 40001 ], to [ 80001 ], nex [ 80001 ]; inline void add ( int x , int y ){ to [ ++ cnt ] = y , nex [ cnt ] = head [ x ], head [ x ] = cnt ;} vector < int > G [ 20001 ], T [ 40010 ]; stack < int > st ; void tarjan ( int k ) { low [ k ] = dfn [ k ] =++ tot , st . e ( k ); int y ; for ( auto to : G [ k ]) { if ( ! dfn [ to ]) { tarjan ( to ), low [ k ] = min ( low [ k ], low [ to ]); if ( low [ to ] >= dfn [ k ]) { T [ ++ num ]. eb ( k ), T [ k ]. eb ( num ); do T [ num ]. eb ( y = st . top ()), T [ st . top ()]. eb ( num ), st . pop (); while ( y != to ); } } else low [ k ] = min ( low [ k ], dfn [ to ]); } }","title":"\u8fde\u901a\u6027"},{"location":"Graph/connection/#\u8fb9\u53cc\u8054\u901a\u5206\u91cf","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int n , m , cnt = 1 , num , col , low [ 500001 ], dfn [ 500001 ], head [ 500001 ], to [ 4000001 ], nex [ 4000001 ]; inline void add ( int x , int y ){ to [ ++ cnt ] = y , nex [ cnt ] = head [ x ], head [ x ] = cnt ;} stack < int > st ; vector < int > ve [ 500001 ]; void tarjan ( int k , int fromi ) { dfn [ k ] = low [ k ] =++ num , st . e ( k ); for ( int i = head [ k ]; i ; i = nex [ i ]) { if ( i == ( fromi ^ 1 )) continue ; if ( ! dfn [ to [ i ]]) tarjan ( to [ i ], i ), low [ k ] = min ( low [ k ], low [ to [ i ]]); else low [ k ] = min ( low [ k ], dfn [ to [ i ]]); } if ( low [ k ] == dfn [ k ]) { int y ; ++ col ; do ve [ col ]. eb ( y = st . top ()), st . pop (); while ( y != k ); } }","title":"\u8fb9\u53cc\u8054\u901a\u5206\u91cf"},{"location":"Graph/connection/#\u5f3a\u8054\u901a\u5206\u91cf","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int n , m , cnt , num , col , f [ 10001 ], deg [ 10001 ], c [ 10001 ], dfn [ 10001 ], low [ 10001 ], ins [ 10001 ], x [ 100001 ], y [ 100001 ], head [ 10001 ], to [ 100001 ], nex [ 100001 ]; inline void add ( int x , int y ){ to [ ++ cnt ] = y , nex [ cnt ] = head [ x ], head [ x ] = cnt ;} stack < int > st ; queue < int > q ; void tarjan ( int k ) { st . e ( k ), ins [ k ] = 1 , dfn [ k ] = low [ k ] =++ num ; for ( int i = head [ k ]; i ; i = nex [ i ]) { if ( ! dfn [ to [ i ]]) tarjan ( to [ i ]), low [ k ] = min ( low [ k ], low [ to [ i ]]); else if ( ins [ to [ i ]]) low [ k ] = min ( low [ k ], dfn [ to [ i ]]); } if ( dfn [ k ] == low [ k ]) { int y ; ++ col ; do c [ y = st . top ()] = col , ins [ y ] = 0 , st . pop (); while ( y != k ); } }","title":"\u5f3a\u8054\u901a\u5206\u91cf"},{"location":"Graph/connection/#\u5e7f\u4e49\u5706\u65b9\u6811","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int n , m , q , cnt , tot , num , x [ 200001 ], y [ 200001 ], low [ 40001 ], dfn [ 40001 ], head [ 40001 ], to [ 80001 ], nex [ 80001 ]; inline void add ( int x , int y ){ to [ ++ cnt ] = y , nex [ cnt ] = head [ x ], head [ x ] = cnt ;} vector < int > G [ 20001 ], T [ 40010 ]; stack < int > st ; void tarjan ( int k ) { low [ k ] = dfn [ k ] =++ tot , st . e ( k ); int y ; for ( auto to : G [ k ]) { if ( ! dfn [ to ]) { tarjan ( to ), low [ k ] = min ( low [ k ], low [ to ]); if ( low [ to ] >= dfn [ k ]) { T [ ++ num ]. eb ( k ), T [ k ]. eb ( num ); do T [ num ]. eb ( y = st . top ()), T [ st . top ()]. eb ( num ), st . pop (); while ( y != to ); } } else low [ k ] = min ( low [ k ], dfn [ to ]); } }","title":"\u5e7f\u4e49\u5706\u65b9\u6811"},{"location":"Graph/flow/","text":"\u6700\u5927\u6d41 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 int S , T , cnt = 1 , head [ 1210 ], to [ 100010 ], nex [ 100010 ], v [ 100010 ], d [ 1210 ], now [ 1210 ]; inline void Add ( int x , int y , int z ){ to [ ++ cnt ] = y , nex [ cnt ] = head [ x ], head [ x ] = cnt , v [ cnt ] = z ;} inline void add ( int x , int y , int z ){ Add ( x , y , z ), Add ( y , x , 0 );} queue < int > q ; int bfs () { while ( ! q . empty ()) q . pop (); q . e ( S ), memset ( d , 0 , sizeof ( d )), d [ S ] = 1 , now [ S ] = head [ S ]; while ( ! q . empty ()) { int k = q . front (); q . pop (); for ( int i = head [ k ]; i ; i = nex [ i ]) { if ( v [ i ] &&! d [ to [ i ]]) { d [ to [ i ]] = d [ k ] + 1 , now [ to [ i ]] = head [ to [ i ]], q . e ( to [ i ]); if ( to [ i ] == T ) return 1 ; } } } return 0 ; } int dinic ( int k , int flow ) { if ( k == T ) return flow ; int rest = flow , t ; for ( int i = now [ k ]; i && rest ; i = nex [ i ]) { now [ k ] = i ; if ( d [ to [ i ]] != d [ k ] + 1 ||! v [ i ]) continue ; t = dinic ( to [ i ], min ( v [ i ], rest )); if ( ! t ) d [ to [ i ]] = 0 ; rest -= t , v [ i ] -= t , v [ i ^ 1 ] += t ; } return flow - rest ; } \u8d39\u7528\u6d41 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 int cnt = 1 , S , T , sum , ans , incf [ 5010 ], pre [ 5010 ], d [ 5010 ], h [ 5010 ], head [ 5010 ], to [ 100010 ], nex [ 100010 ], v [ 100010 ], c [ 100010 ]; inline void Add ( int x , int y , int z , int t ){ to [ ++ cnt ] = y , v [ cnt ] = z , nex [ cnt ] = head [ x ], c [ cnt ] = t , head [ x ] = cnt ;} inline void add ( int x , int y , int z , int t ){ Add ( x , y , z , t ), Add ( y , x , 0 , - t );} priority_queue < pii > q ; bool vis [ 5010 ]; bool dij () { for ( int i = 1 ; i <= n ; ++ i ) if ( vis [ i ]) h [ i ] += d [ i ]; memset ( d , 127 , sizeof ( d )), memset ( incf , 0 , sizeof ( incf )), memset ( vis , 0 , sizeof ( vis )); incf [ S ] = inf , d [ S ] = 0 , q . e ( mp ( 0 , S )); while ( ! q . empty ()) { int now = q . top (). se ; q . pop (); if ( vis [ now ]) continue ; vis [ now ] = 1 ; for ( int i = head [ now ]; i ; i = nex [ i ]) { if ( v [ i ] && Mmin ( d [ to [ i ]], d [ now ] + c [ i ] + h [ now ] - h [ to [ i ]])) incf [ to [ i ]] = min ( v [ i ], incf [ now ]), pre [ to [ i ]] = i , q . e ( mp ( - d [ to [ i ]], to [ i ])); } } return incf [ T ]; } inline void update () { int now = T ; sum += incf [ T ], ans += incf [ T ] * ( d [ T ] - h [ S ] + h [ T ]); while ( now != S ) v [ pre [ now ]] -= incf [ T ], v [ pre [ now ] ^ 1 ] += incf [ T ], now = to [ pre [ now ] ^ 1 ]; }","title":"\u7f51\u7edc\u6d41"},{"location":"Graph/flow/#\u6700\u5927\u6d41","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 int S , T , cnt = 1 , head [ 1210 ], to [ 100010 ], nex [ 100010 ], v [ 100010 ], d [ 1210 ], now [ 1210 ]; inline void Add ( int x , int y , int z ){ to [ ++ cnt ] = y , nex [ cnt ] = head [ x ], head [ x ] = cnt , v [ cnt ] = z ;} inline void add ( int x , int y , int z ){ Add ( x , y , z ), Add ( y , x , 0 );} queue < int > q ; int bfs () { while ( ! q . empty ()) q . pop (); q . e ( S ), memset ( d , 0 , sizeof ( d )), d [ S ] = 1 , now [ S ] = head [ S ]; while ( ! q . empty ()) { int k = q . front (); q . pop (); for ( int i = head [ k ]; i ; i = nex [ i ]) { if ( v [ i ] &&! d [ to [ i ]]) { d [ to [ i ]] = d [ k ] + 1 , now [ to [ i ]] = head [ to [ i ]], q . e ( to [ i ]); if ( to [ i ] == T ) return 1 ; } } } return 0 ; } int dinic ( int k , int flow ) { if ( k == T ) return flow ; int rest = flow , t ; for ( int i = now [ k ]; i && rest ; i = nex [ i ]) { now [ k ] = i ; if ( d [ to [ i ]] != d [ k ] + 1 ||! v [ i ]) continue ; t = dinic ( to [ i ], min ( v [ i ], rest )); if ( ! t ) d [ to [ i ]] = 0 ; rest -= t , v [ i ] -= t , v [ i ^ 1 ] += t ; } return flow - rest ; }","title":"\u6700\u5927\u6d41"},{"location":"Graph/flow/#\u8d39\u7528\u6d41","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 int cnt = 1 , S , T , sum , ans , incf [ 5010 ], pre [ 5010 ], d [ 5010 ], h [ 5010 ], head [ 5010 ], to [ 100010 ], nex [ 100010 ], v [ 100010 ], c [ 100010 ]; inline void Add ( int x , int y , int z , int t ){ to [ ++ cnt ] = y , v [ cnt ] = z , nex [ cnt ] = head [ x ], c [ cnt ] = t , head [ x ] = cnt ;} inline void add ( int x , int y , int z , int t ){ Add ( x , y , z , t ), Add ( y , x , 0 , - t );} priority_queue < pii > q ; bool vis [ 5010 ]; bool dij () { for ( int i = 1 ; i <= n ; ++ i ) if ( vis [ i ]) h [ i ] += d [ i ]; memset ( d , 127 , sizeof ( d )), memset ( incf , 0 , sizeof ( incf )), memset ( vis , 0 , sizeof ( vis )); incf [ S ] = inf , d [ S ] = 0 , q . e ( mp ( 0 , S )); while ( ! q . empty ()) { int now = q . top (). se ; q . pop (); if ( vis [ now ]) continue ; vis [ now ] = 1 ; for ( int i = head [ now ]; i ; i = nex [ i ]) { if ( v [ i ] && Mmin ( d [ to [ i ]], d [ now ] + c [ i ] + h [ now ] - h [ to [ i ]])) incf [ to [ i ]] = min ( v [ i ], incf [ now ]), pre [ to [ i ]] = i , q . e ( mp ( - d [ to [ i ]], to [ i ])); } } return incf [ T ]; } inline void update () { int now = T ; sum += incf [ T ], ans += incf [ T ] * ( d [ T ] - h [ S ] + h [ T ]); while ( now != S ) v [ pre [ now ]] -= incf [ T ], v [ pre [ now ] ^ 1 ] += incf [ T ], now = to [ pre [ now ] ^ 1 ]; }","title":"\u8d39\u7528\u6d41"},{"location":"Graph/treehash/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int T , n , siz [ 101 ], power [ 101 ], g [ 101 ], dep [ 101 ], head [ 101 ], to [ 101 ], nex [ 101 ], cnt , root1 , root2 ; pii f [ 101 ]; void dfs ( int k , int fa ) { siz [ k ] = 1 ; int maxn = 0 ; for ( int i = head [ k ]; i ; i = nex [ i ]) if ( to [ i ] != fa ) dfs ( to [ i ], k ), maxn = max ( maxn , siz [ to [ i ]]), siz [ k ] += siz [ to [ i ]]; if (( n - siz [ k ]) <= n / 2 && maxn <= n / 2 ) root1 ? root2 = k : root1 = k ; } void dfs2 ( int k , int fa ) { dep [ k ] = dep [ fa ] + 1 , g [ k ] = power [ 1 ] * dep [ k ], siz [ k ] = 1 ; pii a [ 51 ]; int tot = 0 ; for ( int i = head [ k ]; i ; i = nex [ i ]) if ( to [ i ] != fa ) dfs2 ( to [ i ], k ), siz [ k ] += siz [ to [ i ]], a [ ++ tot ] = mp ( g [ to [ i ]], to [ i ]); sort ( a + 1 , a + 1 + tot ); int now = 1 ; for ( int i = 1 ; i <= tot ; ++ i ) g [ k ] += g [ a [ i ]. se ] * power [ now ], now += siz [ a [ i ]. se ]; } inline void add ( int x , int y ){ to [ ++ cnt ] = y , nex [ cnt ] = head [ x ], head [ x ] = cnt ;} pii calc () { power [ 0 ] = 1 ; int x ; pii p ; for ( int i = 1 ; i <= 50 ; ++ i ) power [ i ] = power [ i -1 ] * 13331 ; root1 = root2 = 0 , dfs ( tmp , 0 ), dfs2 ( root1 , 0 ), p . fi = g [ root1 ]; root2 ? root1 = root2 : 0 , dfs2 ( root1 , 0 ), p . se = g [ root1 ]; if ( p . fi > p . se ) swap ( p . fi , p . se ); return p ; }","title":"\u6811\u54c8\u5e0c"},{"location":"Math/lucas/","text":"Lucas \u5b9a\u7406 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 inline int power ( int x , int y ) { int s = 1 ; for (; y ; y >>= 1 , x = 1l l * x * x % p )) if ( y & 1 ) s = 1l l * s * x % p ; return s ; } inline int CC ( int n , int m ){ return n - m < 0 || n < 0 ? 0 : 1l l * fr [ n ] * inv [ m ] % p * inv [ n - m ] % p ;} inline int C ( int n , int m ) { if ( m == 0 ) return 1 ; return 1l l * C ( n / p , m / p ) * CC ( n % p , m % p ) % p ; } inline void init () { for ( int i = 1 ; i < p ; ++ i ) fr [ i ] = 1l l * fr [ i -1 ] * i % p ; inv [ p -1 ] = power ( fr [ p -1 ], p -2 ); for ( int i = p -2 ; i >= 1 ; -- i ) inv [ i ] = 1l l * inv [ i + 1 ] * ( i + 1 ) % p ; } exLucas \u5b9a\u7406 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 inline int power ( int x , int y , int p ) { int s = 1 ; for (; y ; y >>= 1 , x = x * x % p ) if ( y & 1 ) s = s * x % p ; return s ; } int exgcd ( int a , int b , int & x , int & y ) { if ( ! b ) return x = 1 , y = 0 , a ; int d = exgcd ( b , a % b , x , y ); int z = x ; x = y , y = z - x * ( a / b ); return d ; } inline int inv ( int x , int p ){ int X , Y ; return exgcd ( x , p , X , Y ),( X % p + p ) % p ;} int n , m , p , fr [ 1000001 ]; int f ( int k , int p , int P ){ if ( ! k ) return 1 ; return f ( k / p , p , P ) * power ( fr [ P ], k / P , P ) % P * fr [ k % P ] % P ;} int g ( int k , int p ) { int s = 0 , P = p ; for (; p <= k ; p = p * P ) s += k / p ; return s ; } int calc ( int p , int c ) { int P = power ( p , c , 1000000 ); fr [ 0 ] = 1 ; for ( int i = 1 ; i <= P ; ++ i ) i % p == 0 ? fr [ i ] = fr [ i -1 ] : fr [ i ] = fr [ i -1 ] * i % P ; int up = f ( n , p , P ), down = f ( m , p , P ) * f ( n - m , p , P ) % P , et = g ( n , p ) - g ( m , p ) - g ( n - m , p ); return up * inv ( down , P ) % P * power ( p , et , P ) % P ; } inline int calc () { int M = 1 , x0 = 0 ; for ( int i = 2 ; i * i <= p ; ++ i ) { if ( p % i == 0 ) { int s = 0 , t , d , p1 , X , Y ; for (; ! ( p % i ); p /= i , ++ s ); t = calc ( i , s ); p1 = power ( i , s , 1000000 ), t = (( calc ( i , s ) - x0 ) % p1 + p1 ) % p1 ; d = exgcd ( M , p1 , X , Y ), X = ( X % p1 + p1 ) % p1 ; X = t / d * X , x0 = ( x0 + M * X ) % ( M * p1 ), M = M * p1 ; } } if ( p != 1 ) { int s = 1 , i = p , t , d , p1 , X , Y ; p1 = power ( i , s , 1000000 ), t = (( calc ( i , s ) - x0 ) % p1 + p1 ) % p1 ; d = exgcd ( M , p1 , X , Y ), X = ( X % p1 + p1 ) % p1 ; X = t / d * X , x0 = ( x0 + M * X ) % ( M * p1 ), M = M * p1 ; } return x0 ; }","title":"Lucas \u5b9a\u7406"},{"location":"Math/lucas/#lucas-\u5b9a\u7406","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 inline int power ( int x , int y ) { int s = 1 ; for (; y ; y >>= 1 , x = 1l l * x * x % p )) if ( y & 1 ) s = 1l l * s * x % p ; return s ; } inline int CC ( int n , int m ){ return n - m < 0 || n < 0 ? 0 : 1l l * fr [ n ] * inv [ m ] % p * inv [ n - m ] % p ;} inline int C ( int n , int m ) { if ( m == 0 ) return 1 ; return 1l l * C ( n / p , m / p ) * CC ( n % p , m % p ) % p ; } inline void init () { for ( int i = 1 ; i < p ; ++ i ) fr [ i ] = 1l l * fr [ i -1 ] * i % p ; inv [ p -1 ] = power ( fr [ p -1 ], p -2 ); for ( int i = p -2 ; i >= 1 ; -- i ) inv [ i ] = 1l l * inv [ i + 1 ] * ( i + 1 ) % p ; }","title":"Lucas \u5b9a\u7406"},{"location":"Math/lucas/#exlucas-\u5b9a\u7406","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 inline int power ( int x , int y , int p ) { int s = 1 ; for (; y ; y >>= 1 , x = x * x % p ) if ( y & 1 ) s = s * x % p ; return s ; } int exgcd ( int a , int b , int & x , int & y ) { if ( ! b ) return x = 1 , y = 0 , a ; int d = exgcd ( b , a % b , x , y ); int z = x ; x = y , y = z - x * ( a / b ); return d ; } inline int inv ( int x , int p ){ int X , Y ; return exgcd ( x , p , X , Y ),( X % p + p ) % p ;} int n , m , p , fr [ 1000001 ]; int f ( int k , int p , int P ){ if ( ! k ) return 1 ; return f ( k / p , p , P ) * power ( fr [ P ], k / P , P ) % P * fr [ k % P ] % P ;} int g ( int k , int p ) { int s = 0 , P = p ; for (; p <= k ; p = p * P ) s += k / p ; return s ; } int calc ( int p , int c ) { int P = power ( p , c , 1000000 ); fr [ 0 ] = 1 ; for ( int i = 1 ; i <= P ; ++ i ) i % p == 0 ? fr [ i ] = fr [ i -1 ] : fr [ i ] = fr [ i -1 ] * i % P ; int up = f ( n , p , P ), down = f ( m , p , P ) * f ( n - m , p , P ) % P , et = g ( n , p ) - g ( m , p ) - g ( n - m , p ); return up * inv ( down , P ) % P * power ( p , et , P ) % P ; } inline int calc () { int M = 1 , x0 = 0 ; for ( int i = 2 ; i * i <= p ; ++ i ) { if ( p % i == 0 ) { int s = 0 , t , d , p1 , X , Y ; for (; ! ( p % i ); p /= i , ++ s ); t = calc ( i , s ); p1 = power ( i , s , 1000000 ), t = (( calc ( i , s ) - x0 ) % p1 + p1 ) % p1 ; d = exgcd ( M , p1 , X , Y ), X = ( X % p1 + p1 ) % p1 ; X = t / d * X , x0 = ( x0 + M * X ) % ( M * p1 ), M = M * p1 ; } } if ( p != 1 ) { int s = 1 , i = p , t , d , p1 , X , Y ; p1 = power ( i , s , 1000000 ), t = (( calc ( i , s ) - x0 ) % p1 + p1 ) % p1 ; d = exgcd ( M , p1 , X , Y ), X = ( X % p1 + p1 ) % p1 ; X = t / d * X , x0 = ( x0 + M * X ) % ( M * p1 ), M = M * p1 ; } return x0 ; }","title":"exLucas \u5b9a\u7406"},{"location":"Math/prufer/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int n , d [ 1000010 ], f [ 1000010 ], p [ 1000010 ]; inline void change () { for ( int i = 1 ; i < n ; ++ i ) ++ d [ f [ i ]]; for ( int i = 1 , j = 1 ; i <= n -2 ; ++ i , ++ j ) { while ( d [ j ]) ++ j ; p [ i ] = f [ j ]; while ( i <= n -2 &&!-- d [ p [ i ]] && p [ i ] < j ) p [ i + 1 ] = f [ p [ i ]], ++ i ; } } inline void recover () { for ( int i = 1 ; i <= n -2 ; ++ i ) ++ d [ p [ i ]]; p [ n -1 ] = n ; for ( int i = 1 , j = 1 ; i < n ; ++ i , ++ j ) { while ( d [ j ]) ++ j ; f [ j ] = p [ i ]; while ( i < n &&!-- d [ p [ i ]] && p [ i ] < j ) f [ p [ i ]] = p [ i + 1 ], ++ i ; } }","title":"prufer \u5e8f"},{"location":"Math/Linear/determinant/","text":"\u666e\u901a\u9ad8\u6d88 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int n , p , f [ 610 ][ 610 ]; inline void del ( int x , int y , int z ){ for ( int i = 1 ; i <= n ; ++ i ) f [ x ][ i ] = ( f [ x ][ i ] -1ll * z * f [ y ][ i ] % p + p ) % p ;} inline void swp ( int x , int y ){ swap ( f [ x ], f [ y ]);} inline int solve () { int ans = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int pos = 0 ; for ( int j = i ; j <= n ; ++ j ) if ( f [ j ][ i ]){ pos = j ; break ;} if ( ! pos ) return 0 ; if ( pos != i ) ans = Cdel ( 0 , ans ); for ( int j = 1 ; j <= n ; ++ j ) swap ( f [ pos ][ j ], f [ i ][ j ]); for ( int j = i ; j <= n ; ++ j ) { int v = Cmul ( f [ j ][ i ], power ( f [ i ][ i ], MOD -2 )); for ( int k = i ; k <= n ; ++ k ) Mdel ( f [ j ][ k ], Cmul ( f [ i ][ k ], v )); } Mmul ( ans , f [ i ][ i ]); } return ans ; } \u8f97\u8f6c\u76f8\u9664\u6cd5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int n , p , f [ 610 ][ 610 ]; inline void del ( int x , int y , int z ){ for ( int i = 1 ; i <= n ; ++ i ) f [ x ][ i ] = ( f [ x ][ i ] -1ll * z * f [ y ][ i ] % p + p ) % p ;} inline void swp ( int x , int y ){ swap ( f [ x ], f [ y ]);} inline int solve () { int ans = 1 ; for ( int i = n ; i >= 1 ; -- i ) { for ( int j = 1 ; j < i ; ++ j ) { while ( f [ j ][ i ] && f [ i ][ i ]) { if ( f [ j ][ i ] > f [ i ][ i ]) del ( j , i , f [ j ][ i ] / f [ i ][ i ]); else del ( i , j , f [ i ][ i ] / f [ j ][ i ]); } if ( f [ j ][ i ]) ans = p - ans , swp ( i , j ); } ans = 1l l * ans * f [ i ][ i ] % p ; } return ans ; }","title":"\u884c\u5217\u5f0f\u6c42\u503c"},{"location":"Math/Linear/determinant/#\u666e\u901a\u9ad8\u6d88","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int n , p , f [ 610 ][ 610 ]; inline void del ( int x , int y , int z ){ for ( int i = 1 ; i <= n ; ++ i ) f [ x ][ i ] = ( f [ x ][ i ] -1ll * z * f [ y ][ i ] % p + p ) % p ;} inline void swp ( int x , int y ){ swap ( f [ x ], f [ y ]);} inline int solve () { int ans = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int pos = 0 ; for ( int j = i ; j <= n ; ++ j ) if ( f [ j ][ i ]){ pos = j ; break ;} if ( ! pos ) return 0 ; if ( pos != i ) ans = Cdel ( 0 , ans ); for ( int j = 1 ; j <= n ; ++ j ) swap ( f [ pos ][ j ], f [ i ][ j ]); for ( int j = i ; j <= n ; ++ j ) { int v = Cmul ( f [ j ][ i ], power ( f [ i ][ i ], MOD -2 )); for ( int k = i ; k <= n ; ++ k ) Mdel ( f [ j ][ k ], Cmul ( f [ i ][ k ], v )); } Mmul ( ans , f [ i ][ i ]); } return ans ; }","title":"\u666e\u901a\u9ad8\u6d88"},{"location":"Math/Linear/determinant/#\u8f97\u8f6c\u76f8\u9664\u6cd5","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int n , p , f [ 610 ][ 610 ]; inline void del ( int x , int y , int z ){ for ( int i = 1 ; i <= n ; ++ i ) f [ x ][ i ] = ( f [ x ][ i ] -1ll * z * f [ y ][ i ] % p + p ) % p ;} inline void swp ( int x , int y ){ swap ( f [ x ], f [ y ]);} inline int solve () { int ans = 1 ; for ( int i = n ; i >= 1 ; -- i ) { for ( int j = 1 ; j < i ; ++ j ) { while ( f [ j ][ i ] && f [ i ][ i ]) { if ( f [ j ][ i ] > f [ i ][ i ]) del ( j , i , f [ j ][ i ] / f [ i ][ i ]); else del ( i , j , f [ i ][ i ] / f [ j ][ i ]); } if ( f [ j ][ i ]) ans = p - ans , swp ( i , j ); } ans = 1l l * ans * f [ i ][ i ] % p ; } return ans ; }","title":"\u8f97\u8f6c\u76f8\u9664\u6cd5"},{"location":"Math/Linear/gauss/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int n , flag1 = 1 , flag2 = 1 , f [ 501 ][ 501 ]; inline int Gauss () { int now = 1 ; for ( int i = 1 , pos = 0 ; i <= n ; ++ i , pos = 0 ) { for ( int j = now ; j <= n ; ++ j ) if ( f [ j ][ i ]) pos = j ; if ( ! pos ){ flag1 = 0 ; continue ;} for ( int j = 0 ; j <= n ; ++ j ) swap ( f [ pos ][ j ], f [ now ][ j ]); for ( int j = 1 ; j <= n ; ++ j ) { if ( j == now ) continue ; int rate = Cmul ( f [ j ][ i ], power ( f [ now ][ i ], MOD -2 )); for ( int k = 0 ; k <= n ; ++ k ) Mdel ( f [ j ][ k ], Cmul ( f [ now ][ k ], rate )); } ++ now ; } if ( now <= n ) { while ( now <= n ) if ( f [ now ++ ][ 0 ] != 0 ) return -1 ; return 0 ; } return 1 ; }","title":"\u9ad8\u65af\u6d88\u5143"},{"location":"Math/Linear/inv/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int n , f [ 410 ][ 810 ]; inline int INV () { for ( int i = 1 ; i <= n ; ++ i ) f [ i ][ i + n ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int pos = 0 ; for ( int j = i ; j <= n ; ++ j ) if ( f [ j ][ i ]){ pos = j ; break ;} if ( ! pos ) return 0 ; for ( int j = 1 ; j <= n * 2 ; ++ j ) swap ( f [ i ][ j ], f [ pos ][ j ]); int tmp = power ( f [ i ][ i ], MOD -2 ); for ( int j = 1 ; j <= n ; ++ j ) { if ( j == i ) continue ; int rate = Cmul ( f [ j ][ i ], tmp ); for ( int k = 1 ; k <= n * 2 ; ++ k ) Mdel ( f [ j ][ k ], Cmul ( f [ i ][ k ], rate )); } } for ( int i = 1 ; i <= n ; ++ i ) { int tmp = power ( f [ i ][ i ], MOD -2 ); for ( int j = n + 1 ; j <= n * 2 ; ++ j ) Mmul ( f [ i ][ j ], tmp ); } return 1 ; }","title":"\u77e9\u9635\u6c42\u9006"},{"location":"Math/Poly/FWT/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 inline void AND ( vector < int >& ve , int opt = 1 ) { int n = ve . size (); if ( opt == 1 ) for ( int k = 2 ; k <= n ; k <<= 1 ) { for ( int i = 0 ; i < n ; i += k ) { for ( int j = i ; j < i + ( k >> 1 ); ++ j ) Madd ( ve [ j ], ve [ j + ( k >> 1 )]); } } else for ( int k = 2 ; k <= n ; k <<= 1 ) { for ( int i = 0 ; i < n ; i += k ) { for ( int j = i ; j < i + ( k >> 1 ); ++ j ) Mdel ( ve [ j ], ve [ j + ( k >> 1 )]); } } } inline void OR ( vector < int >& ve , int opt = 1 ) { int n = ve . size (); if ( opt == 1 ) for ( int k = 2 ; k <= n ; k <<= 1 ) { for ( int i = 0 ; i < n ; i += k ) { for ( int j = i ; j < i + ( k >> 1 ); ++ j ) Madd ( ve [ j + ( k >> 1 )], ve [ j ]); } } else for ( int k = 2 ; k <= n ; k <<= 1 ) { for ( int i = 0 ; i < n ; i += k ) { for ( int j = i ; j < i + ( k >> 1 ); ++ j ) Mdel ( ve [ j + ( k >> 1 )], ve [ j ]); } } } inline void XOR ( vector < int >& ve , int opt = 1 ) { int n = ve . size (); for ( int k = 2 ; k <= n ; k <<= 1 ) { for ( int i = 0 ; i < n ; i += k ) { for ( int j = i ; j < i + ( k >> 1 ); ++ j ) { Madd ( ve [ j ], ve [ j + ( k >> 1 )]); ve [ j + ( k >> 1 )] = Cdel ( ve [ j ], ve [ j + ( k >> 1 )], ve [ j + ( k >> 1 )]); } } } int tmp = power ( inv2 , __lg ( n )); if ( opt == -1 ) for ( int i = 0 ; i < n ; ++ i ) Mmul ( ve [ i ], tmp ); } inline vi MUL ( vi a , vi b ) { int N = a . size (), n = __lg ( N ); static vi c , A [ 21 ], B [ 21 ], C [ 21 ]; c . resize ( N ); for ( int i = 0 ; i <= n ; ++ i ) { A [ i ]. clear (), B [ i ]. clear (); A [ i ]. resize ( N ), B [ i ]. resize ( N ), C [ i ]. resize ( N ); } for ( int i = 0 ; i < N ; ++ i ) A [ __builtin_popcount ( i )][ i ] = a [ i ]; for ( int i = 0 ; i < N ; ++ i ) B [ __builtin_popcount ( i )][ i ] = b [ i ]; for ( int i = 0 ; i <= n ; ++ i ) OR ( A [ i ]), OR ( B [ i ]); for ( int i = 0 ; i <= n ; ++ i ) { for ( int j = 0 ; j + i <= n ; ++ j ) { for ( int k = 0 ; k < N ; ++ k ) Madd ( C [ i + j ][ k ], Cmul ( A [ i ][ k ], B [ j ][ k ])); } } for ( int i = 0 ; i <= n ; ++ i ) OR ( C [ i ], -1 ); for ( int i = 0 ; i < N ; ++ i ) c [ i ] = C [ __builtin_popcount ( i )][ i ]; return c ; }","title":"\u96c6\u5408\u5e42\u7ea7\u6570"},{"location":"Math/Poly/interpolation/","text":"\u6c42\u591a\u9879\u5f0f\u7cfb\u6570\u8868\u793a\u6cd5\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int n , m , ans , x [ 2010 ], y [ 2010 ], d [ 2010 ], a [ 2010 ], b [ 2010 ]; inline void mian () { read ( n , m ), a [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { read ( x [ i ], y [ i ]); for ( int j = i ; j >= 1 ; -- j ) a [ j ] = Cdel ( a [ j -1 ], Cmul ( x [ i ], a [ j ])); Mmul ( a [ 0 ], MOD - x [ i ]); } for ( int i = 1 , v ; i <= n ; ++ i ) { int c = power ( MOD - x [ i ], MOD -2 ); v = 1 , b [ 0 ] = Cmul ( a [ 0 ], c ); for ( int j = 1 ; j < n ; ++ j ) b [ j ] = Cmul ( Cdel ( a [ j ], b [ j -1 ]), c ); for ( int j = 1 ; j <= n ; ++ j ) if ( i != j ) Mmul ( v , Cdel ( x [ i ], x [ j ])); v = Cmul ( y [ i ], power ( v , MOD -2 )); for ( int j = 0 ; j < n ; ++ j ) Madd ( d [ j ], Cmul ( v , b [ j ])); } for ( int j = 0 ; j < n ; ++ j ) Madd ( ans , Cmul ( power ( m , j ), d [ j ])); write ( ans ); } \u6c42\u70b9\u503c\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int n , k , ans , x [ 2001 ], y [ 2001 ]; inline void mian () { read ( n , k ); for ( int i = 1 ; i <= n ; ++ i ) read ( x [ i ], y [ i ]); for ( int i = 1 ; i <= n ; ++ i ) { int up = y [ i ], down = 1 ; for ( int j = 1 ; j <= n ; ++ j ) { if ( i == j ) continue ; Mmul ( up , k - x [ j ]), Mmul ( down , x [ i ] - x [ j ]); } Madd ( ans , Cmul ( up , power ( down , MOD -2 ))); } write ( ans ); }","title":"\u62c9\u683c\u6717\u65e5\u63d2\u503c"},{"location":"Math/Poly/poly/","text":"\u611f\u89c9\u5e38\u6570\u8fd8\u7b97\u6bd4\u8f83\u4f18\u79c0 QwQ\u3002\u4ee5\u4e0b\u6570\u636e\u8303\u56f4\u9664\u4e86 FFT \u5747\u662f \\(10^5\\) \u3002 FFT( \\(10^6\\) ): \\(270\\text{ms}\\) \u6c42\u9006: \\(33\\text{ms}\\) \u5f00\u6839: \\(53\\text{ms}\\) \u5bf9\u6570\u51fd\u6570: \\(50\\text{ms}\\) \u6307\u6570\u51fd\u6570: \\(175\\text{ms}\\) \uff08\u592a\u62c9\u4e86\uff09 \u9664\u6cd5\uff08\u53d6\u6a21\uff09: \\(50\\text{ms}\\) \u5e42\u51fd\u6570: \\(320\\text{ms}\\) \uff08\u592a\u62c9\u4e86\uff09 \u6ce8\u610f\u66f4\u6539 MAXN\u3002\u4f7f\u7528\u524d\u8981\u8c03\u7528 init() \u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 namespace Poly { const int MAXN = 200000 ; int Shape , Invn [ MAXN + 10 ], R [ MAXN * 4 + 10 ], Prt [ MAXN * 4 ]; inline void init () { Invn [ 0 ] = 1 ; for ( int i = 1 ; i <= MAXN ; ++ i ) Invn [ i ] = Cmul ( Invn [ i -1 ], i ); int tmp = power ( Invn [ MAXN ], MOD -2 ); for ( int i = MAXN ; i >= 1 ; -- i ) Invn [ i ] = Cmul ( tmp , Invn [ i -1 ]), Mmul ( tmp , i ); } inline int inv ( int x ){ return x <= MAXN ? Invn [ x ] : power ( x , MOD -2 );} inline void NTT ( vi & A , int n , int opt ) { static ull B [ MAXN * 4 + 10 ]; ull iv = power ( n , MOD -2 ); A . resize ( n ); for ( int i = 0 ; i < n ; ++ i ) B [ i ] = A [ R [ i ]]; for ( int mid = 1 ; mid < n ; mid <<= 1 ) { for ( int j = 0 ; j < n ; j += mid << 1 ) { for ( int k = j ; k < j + mid ; ++ k ) { ull x = B [ k ], y = Prt [ mid + k - j ] * B [ k + mid ] % MOD ; B [ k ] = x + y , B [ k + mid ] = x + MOD - y ; } } } if ( opt ) for ( int i = 0 ; i < n ; ++ i ) A [ i ] = B [ i ] % MOD ; else { reverse ( B + 1 , B + n ); for ( int i = 0 ; i < n ; ++ i ) A [ i ] = Cmul ( B [ i ] % MOD , iv );} } inline void init ( int lim ) { if ( lim == Shape ) return ; int n = lim / 2 ; Shape = lim ; for ( int i = 0 ; i < lim ; ++ i ) R [ i ] = ( R [ i >> 1 ] >> 1 ) | (( i & 1 ) ? n : 0 ); for ( int i = 1 ; i < lim ; i <<= 1 ) { int wm = power ( Root ,( MOD -1 ) / ( i << 1 )); Prt [ i ] = 1 ; for ( int j = 1 ; j < i ; ++ j ) Prt [ i + j ] = Cmul ( Prt [ i + j -1 ], wm ); } } inline vi del ( vi A , vi B , int N = -1 ) { if ( ~ N ) A . resize ( N + 1 ), B . resize ( N + 1 ); int n = A . size () -1 ; for ( int i = 0 ; i <= n ; ++ i ) Mdel ( A [ i ], B [ i ]); return A ; } inline vi add ( vi A , vi B , int N = -1 ) { if ( ~ N ) A . resize ( N + 1 ), B . resize ( N + 1 ); int n = A . size () -1 ; for ( int i = 0 ; i <= n ; ++ i ) Madd ( A [ i ], B [ i ]); return A ; } inline vi mul ( vi A , int k , int N = -1 ) { if ( ~ N ) A . resize ( N + 1 ); int n = A . size () -1 ; for ( int i = 0 ; i <= n ; ++ i ) Mmul ( A [ i ], k ); return A ; } inline vi inte ( vi A , int N = -1 ) { if ( ~ N ) A . resize ( N + 1 ); int n = A . size (); A . resize ( n + 1 ); for ( int i = n ; i > 0 ; -- i ) A [ i ] = Cmul ( A [ i -1 ], inv ( i )); return A [ 0 ] = 0 , A ; } inline vi der ( vi A , int N = -1 ) { if ( ~ N ) A . resize ( N + 1 ); int n = A . size () -2 ; for ( int i = 0 ; i <= n ; ++ i ) A [ i ] = Cmul ( A [ i + 1 ], i + 1 ); return A . resize ( n + 1 ), A ; } inline vi FFT ( vi A , vi B , int N1 = -1 , int N2 = -1 ) { if ( N1 != -1 ) A . resize ( N1 + 1 ); if ( N2 != -1 ) B . resize ( N2 + 1 ); int n = A . size () -1 , m = B . size () -1 , N = 1 , len = 0 ; while ( N <= n + m ) N <<= 1 , ++ len ; init ( N ), NTT ( A , N , 1 ), NTT ( B , N , 1 ); for ( int i = 0 ; i < N ; ++ i ) A [ i ] = Cmul ( A [ i ], B [ i ]); return NTT ( A , N , 0 ), A . resize ( n + m + 1 ), A ; } inline vi inv ( vi A , int N = -1 ) { if ( N != -1 ) A . resize ( N + 1 ); vi B = {( int ) power ( A [ 0 ], MOD -2 )}; int n = A . size () -1 , nn = n ; for ( n = 1 ; n <= nn + 1 ; n <<= 1 ) { vi TB = B , C ( n * 2 ); init ( n << 1 ); copy ( A . begin (), A . begin () + min ( nn + 1 , 2 * n ), C . begin ()); NTT ( C , n << 1 , 1 ), NTT ( B , n << 1 , 1 ); for ( int i = 0 ; i < ( n << 1 ); ++ i ) C [ i ] = 1l l * C [ i ] * B [ i ] % MOD ; NTT ( C , n << 1 , 0 ); C . resize ( n << 1 ); fill ( C . begin (), C . begin () + n , 0 ), NTT ( C , n << 1 , 1 ); for ( int i = 0 ; i < ( n << 1 ); ++ i ) B [ i ] = 1l l * B [ i ] * ( MOD - C [ i ]) % MOD ; NTT ( B , n << 1 , 0 ); B . resize ( n << 1 ), move ( TB . begin (), TB . end (), B . begin ()); } return B . resize ( nn + 1 ), B ; } inline vi ln ( vi A , int N = -1 ){ return inte ( FFT ( der ( A , N ), inv ( A , N )));} inline vi exp ( vi A , int N = -1 ) { if ( ~ N ) A . resize ( N + 1 ); int m = A . size () -1 ; static vi B , C ; B . clear (), C . clear (), B . eb ( 1 ); for ( int n = 2 ; n <= m ; n <<= 1 ) B . resize ( n + 1 ), C = del ( A , ln ( B ), n ), Madd ( C [ 0 ], 1 ), B = FFT ( B , C , n , n ); C = del ( A , ln ( B ), m ), Madd ( C [ 0 ], 1 ); B . resize ( m + 1 ), C . resize ( m + 1 ); B = FFT ( B , C , m , m ), B . resize ( m + 1 ); return B ; } inline vi div ( vi A , vi B , int N1 = -1 , int N2 = -1 ) { if ( ~ N1 ) A . resize ( N1 + 1 ); if ( ~ N2 ) B . resize ( N2 + 1 ); int n = A . size () -1 , m = B . size () -1 ; reverse ( A . begin (), A . end ()), reverse ( B . begin (), B . end ()); A = FFT ( A , inv ( B , n - m + 1 )), A . resize ( n - m + 1 ), reverse ( A . begin (), A . end ()); return A ; } }","title":"\u591a\u9879\u5f0f"},{"location":"Math/number%20theory/BSGS/","text":"BSGS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 inline int power ( int a , int b , int p ) { int ans = 1 ; for (; b ; a = a * a % p , b >>= 1 ) if ( b & 1 ) ans = ans * a % p ; return ans ; } inline int BSGS ( int a , int b , int p ) { int t = sqrt ( p ) + 1 ; unordered_map < int , int > mp ; mp . clear (), b %= p ; for ( int j = 0 , now = b ; j < t ; now = now * a % p , ++ j ) mp [ now ] = j ; a = power ( a , t , p ); if ( ! a ) return b ? -1 : 1 ; for ( int i = 0 , now = 1 ; i <= t ; now = now * a % p , ++ i ) { int j = mp . find ( now ) == mp . end () ? -1 : mp [ now ]; if ( j >= 0 && i * t - j >= 0 ) return i * t - j ; } return -1 ; } exBSGS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 inline int power ( int a , int b , int p ) { int ans = 1 ; for (; b ; a = a * a % p , b >>= 1 ) if ( b & 1 ) ans = ans * a % p ; return ans ; } inline int BSGS ( int a , int b , int p ) { int t = sqrt ( p ) + 1 ; unordered_map < int , int > mp ; mp . clear (), b %= p ; for ( int j = 0 , now = b ; j < t ; now = now * a % p , ++ j ) mp [ now ] = j ; a = power ( a , t , p ); if ( ! a ) return b ? -1 : 1 ; for ( int i = 0 , now = 1 ; i <= t ; now = now * a % p , ++ i ) { int j = mp . find ( now ) == mp . end () ? -1 : mp [ now ]; if ( j >= 0 && i * t - j >= 0 ) return i * t - j ; } return -1 ; } void exgcd ( int a , int b , int & x , int & y ) { if ( ! b ) return x = 1 , y = 0 , void (); exgcd ( b , a % b , x , y ); int z = x ; x = y , y = z - x * ( a / b ); } int gcd ( int a , int b ){ return b ? gcd ( b , a % b ) : a ;} inline int inv ( int b , int p ){ int x , y ; exgcd ( b , p , x , y ), x = ( x % p + p ) % p ; return x ;} inline int exBSGS ( int a , int b , int p ) { b %= p ; if ( b == 1 || p == 1 ) return 0 ; int na = 1 , k = 0 , g = gcd ( a , p ); while ( g > 1 ) { if ( b % g != 0 ) return -1 ; ++ k , b /= g , p /= g , na = na * ( a / g ) % p , g = gcd ( a , p ); if ( na == b ) return k ; } int f = BSGS ( a , b * inv ( na , p ) % p , p ); if ( f == -1 ) return -1 ; return f + k ; }","title":"BSGS"},{"location":"Math/number%20theory/BSGS/#bsgs","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 inline int power ( int a , int b , int p ) { int ans = 1 ; for (; b ; a = a * a % p , b >>= 1 ) if ( b & 1 ) ans = ans * a % p ; return ans ; } inline int BSGS ( int a , int b , int p ) { int t = sqrt ( p ) + 1 ; unordered_map < int , int > mp ; mp . clear (), b %= p ; for ( int j = 0 , now = b ; j < t ; now = now * a % p , ++ j ) mp [ now ] = j ; a = power ( a , t , p ); if ( ! a ) return b ? -1 : 1 ; for ( int i = 0 , now = 1 ; i <= t ; now = now * a % p , ++ i ) { int j = mp . find ( now ) == mp . end () ? -1 : mp [ now ]; if ( j >= 0 && i * t - j >= 0 ) return i * t - j ; } return -1 ; }","title":"BSGS"},{"location":"Math/number%20theory/BSGS/#exbsgs","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 inline int power ( int a , int b , int p ) { int ans = 1 ; for (; b ; a = a * a % p , b >>= 1 ) if ( b & 1 ) ans = ans * a % p ; return ans ; } inline int BSGS ( int a , int b , int p ) { int t = sqrt ( p ) + 1 ; unordered_map < int , int > mp ; mp . clear (), b %= p ; for ( int j = 0 , now = b ; j < t ; now = now * a % p , ++ j ) mp [ now ] = j ; a = power ( a , t , p ); if ( ! a ) return b ? -1 : 1 ; for ( int i = 0 , now = 1 ; i <= t ; now = now * a % p , ++ i ) { int j = mp . find ( now ) == mp . end () ? -1 : mp [ now ]; if ( j >= 0 && i * t - j >= 0 ) return i * t - j ; } return -1 ; } void exgcd ( int a , int b , int & x , int & y ) { if ( ! b ) return x = 1 , y = 0 , void (); exgcd ( b , a % b , x , y ); int z = x ; x = y , y = z - x * ( a / b ); } int gcd ( int a , int b ){ return b ? gcd ( b , a % b ) : a ;} inline int inv ( int b , int p ){ int x , y ; exgcd ( b , p , x , y ), x = ( x % p + p ) % p ; return x ;} inline int exBSGS ( int a , int b , int p ) { b %= p ; if ( b == 1 || p == 1 ) return 0 ; int na = 1 , k = 0 , g = gcd ( a , p ); while ( g > 1 ) { if ( b % g != 0 ) return -1 ; ++ k , b /= g , p /= g , na = na * ( a / g ) % p , g = gcd ( a , p ); if ( na == b ) return k ; } int f = BSGS ( a , b * inv ( na , p ) % p , p ); if ( f == -1 ) return -1 ; return f + k ; }","title":"exBSGS"},{"location":"Math/number%20theory/CRT/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int exgcd ( int a , int b , int & x , int & y ) { if ( ! b ) return x = 1 , y = 0 , a ; int d = exgcd ( b , a % b , x , y ); int z = x ; x = y , y = z - x * ( a / b ); return d ; } int gcd ( int a , int b ){ return b ? gcd ( b , a % b ) : a ;} int m [ 100010 ], a [ 100010 ], n , M = 1 , x0 = 0 , MM , b , k , x , y ; inline int calc () { for ( int i = 1 ; i <= n ; ++ i ) { b = a [ i ] - x0 ; int d = exgcd ( M , m [ i ], k , y ); if ( b % d != 0 ){ write ( 114514 ); return ;} k = ( k * b / d % ( m [ i ] / d ) + m [ i ] / d ) % ( m [ i ] / d ), MM = M / gcd ( M , m [ i ]) * m [ i ]; x0 = (( x0 + k * M ) % MM + MM ) % MM , M = MM ; } return x0 ; }","title":"CRT"},{"location":"Math/number%20theory/gcd/","text":"Binary GCD 1 2 3 4 5 6 7 inline int gcd ( int a , int b ) { int az = __builtin_ctz ( a ), bz = __builtin_ctz ( b ); int z = min ( az , bz ), tmp ; b >>= bz ; while ( a ) a >>= az , tmp = a - b , az = __builtin_ctz ( tmp ), b = min ( a , b ), a = abs ( tmp ); return b << z ; } \u503c\u57df\u9884\u5904\u7406 GCD 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 bitset < 1000010 > v ; int cnt , ans , f [ 1000010 ][ 3 ], c [ 1010 ][ 1010 ], pr [ 300010 ]; inline int gcd ( int x , int y ) { int ans = 1 ; for ( int i = 0 ; i < 3 ; ++ i ) { int tmp = f [ x ][ i ] > 1000 ? y % f [ x ][ i ] ? 1 : f [ x ][ i ] : c [ f [ x ][ i ]][ y % f [ x ][ i ]]; y /= tmp , ans *= tmp ; } return ans ; } inline void mian () { f [ 1 ][ 0 ] = f [ 1 ][ 1 ] = f [ 1 ][ 2 ] = 1 ; for ( int i = 2 ; i <= 1000000 ; ++ i ) { if ( ! v [ i ]) pr [ ++ cnt ] = i , f [ i ][ 0 ] = f [ i ][ 1 ] = 1 , f [ i ][ 2 ] = i ; for ( int j = 1 ; j <= cnt && i * pr [ j ] <= 1000000 ; ++ j ) { v [ i * pr [ j ]] = 1 ; f [ i * pr [ j ]][ 0 ] = f [ i ][ 0 ] * pr [ j ]; f [ i * pr [ j ]][ 1 ] = f [ i ][ 1 ]; f [ i * pr [ j ]][ 2 ] = f [ i ][ 2 ]; sort ( f [ i * pr [ j ]], f [ i * pr [ j ]] + 3 ); if ( i % pr [ j ] == 0 ) break ; } } for ( int i = 1 ; i <= 1000 ; ++ i ) c [ i ][ 0 ] = c [ 0 ][ i ] = i ; for ( int i = 1 ; i <= 1000 ; ++ i ) for ( int j = 1 ; j <= i ; ++ j ) c [ i ][ j ] = c [ j ][ i ] = c [ j ][ i % j ]; }","title":"Gcd"},{"location":"Math/number%20theory/gcd/#binary-gcd","text":"1 2 3 4 5 6 7 inline int gcd ( int a , int b ) { int az = __builtin_ctz ( a ), bz = __builtin_ctz ( b ); int z = min ( az , bz ), tmp ; b >>= bz ; while ( a ) a >>= az , tmp = a - b , az = __builtin_ctz ( tmp ), b = min ( a , b ), a = abs ( tmp ); return b << z ; }","title":"Binary GCD"},{"location":"Math/number%20theory/gcd/#\u503c\u57df\u9884\u5904\u7406-gcd","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 bitset < 1000010 > v ; int cnt , ans , f [ 1000010 ][ 3 ], c [ 1010 ][ 1010 ], pr [ 300010 ]; inline int gcd ( int x , int y ) { int ans = 1 ; for ( int i = 0 ; i < 3 ; ++ i ) { int tmp = f [ x ][ i ] > 1000 ? y % f [ x ][ i ] ? 1 : f [ x ][ i ] : c [ f [ x ][ i ]][ y % f [ x ][ i ]]; y /= tmp , ans *= tmp ; } return ans ; } inline void mian () { f [ 1 ][ 0 ] = f [ 1 ][ 1 ] = f [ 1 ][ 2 ] = 1 ; for ( int i = 2 ; i <= 1000000 ; ++ i ) { if ( ! v [ i ]) pr [ ++ cnt ] = i , f [ i ][ 0 ] = f [ i ][ 1 ] = 1 , f [ i ][ 2 ] = i ; for ( int j = 1 ; j <= cnt && i * pr [ j ] <= 1000000 ; ++ j ) { v [ i * pr [ j ]] = 1 ; f [ i * pr [ j ]][ 0 ] = f [ i ][ 0 ] * pr [ j ]; f [ i * pr [ j ]][ 1 ] = f [ i ][ 1 ]; f [ i * pr [ j ]][ 2 ] = f [ i ][ 2 ]; sort ( f [ i * pr [ j ]], f [ i * pr [ j ]] + 3 ); if ( i % pr [ j ] == 0 ) break ; } } for ( int i = 1 ; i <= 1000 ; ++ i ) c [ i ][ 0 ] = c [ 0 ][ i ] = i ; for ( int i = 1 ; i <= 1000 ; ++ i ) for ( int j = 1 ; j <= i ; ++ j ) c [ i ][ j ] = c [ j ][ i ] = c [ j ][ i % j ]; }","title":"\u503c\u57df\u9884\u5904\u7406 GCD"},{"location":"Math/number%20theory/genshin/","text":"\u6ce8\u610f\u5148\u8c03\u7528 sieve() \u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 int T , n , d , m , cnt , pr [ 100010 ]; bitset < 2000010 > v ; vector < int > ve , ans ; int gcd ( int x , int y ){ return y ? gcd ( y , x % y ) : x ;} inline int power ( int x , int y , int z ) { int s = 1 ; for (; y ; y >>= 1 , x = 1l l * x * x % z ) if ( y & 1 ) s = 1l l * s * x % z ; return s ; } inline int phi ( int x ) { int y = x ; for ( int i = 2 ; i * i <= x ; ++ i ) { if ( x % i == 0 ) { y = y / i * ( i -1 ); while ( x % i == 0 ) x /= i ; } } if ( x != 1 ) y = y / x * ( x -1 ); return y ; } inline void sieve () { for ( int i = 2 ; i <= 1000000 ; ++ i ) { if ( ! v [ i ]) pr [ ++ cnt ] = i ; for ( int j = 1 ; j <= cnt && i * pr [ j ] <= 1000000 ; ++ j ) { v [ i * pr [ j ]] = 1 ; if ( i % pr [ j ] == 0 ) break ; } } v . reset (), v [ 2 ] = v [ 4 ] = 1 ; for ( int i = 2 ; i <= cnt ; ++ i ) { for ( ll j = pr [ i ]; j <= 1000000 ; j *= pr [ i ]) v [ j ] = 1 , v [ 2 * j ] = 1 ; } } inline vi calc ( int n ) { read ( n , d ), m = phi ( n ), ans . clear (), ve . clear (); int mm = m , g = 1 ; if ( ! v [ n ]) return ans ; for ( int i = 2 ; i * i <= m ; ++ i ) if ( m % i == 0 ){ ve . eb ( i ); while ( m % i == 0 ) m /= i ;} if ( m != 1 ) ve . eb ( m ); for (; g < n ; ++ g ) { if ( gcd ( g , n ) != 1 ) continue ; int fl = 1 ; for ( auto p : ve ) if ( power ( g , mm / p , n ) == 1 ){ fl = 0 ; break ;} if ( fl ) break ; } for ( int i = 1 , nw = g ; i <= mm ; ++ i , nw = 1l l * nw * g % n ) if ( gcd ( i , mm ) == 1 ) ans . eb ( nw ); return ans ; }","title":"Genshin"},{"location":"Math/number%20theory/millerrabin/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 inline bool chk ( int n ) { if ( n < 3 || n % 2 == 0 ) return n == 2 ; int u = n -1 , t = 0 ; while ( u % 2 == 0 ) u /= 2 , ++ t ; for ( int i = 0 , s , a , v ; i < 8 ; ++ i ) { a = rd ( 2 , n -1 ), v = power ( a , u , n ); if ( v == 1 ) continue ; for ( s = 0 ; s < t ; ++ s ) { if ( v == n -1 ) break ; v = mul ( v , v , n ); } if ( s == t ) return 0 ; } return 1 ; }","title":"Millerrabin"},{"location":"Math/number%20theory/oper/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 int cnt , n , pr [ 2000010 ]; ui a [ 20000010 ], ans ; bitset < 20000010 > v ; inline void init () { for ( int i = 2 ; i <= 20000000 ; ++ i ) { if ( ! v [ i ]) pr [ ++ cnt ] = i ; for ( int j = 1 ; j <= cnt && i * pr [ j ] <= 20000000 ; ++ j ) { v [ i * pr [ j ]] = 1 ; if ( i % pr [ j ] == 0 ) break ; } } } inline void dirichlet () { for ( int i = 1 ; i <= cnt ; ++ i ) { for ( int j = 1 ; j * pr [ i ] <= 20000000 ; ++ j ) Madd ( a [ j * pr [ i ]], a [ j ]); } } inline void modius () { for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = i + i ; j <= n ; j += i ) Mdel ( a [ j ], a [ i ]); } }","title":"Oper"},{"location":"Math/number%20theory/pollardrho/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 mt19937_64 rnd ( time ( 0 ) ^ ( ull )( new char )); #define rd(l,r) ((l)+rnd()%((int)((r)-(l)+1))) inline int mul ( int x , int y , int z ) { int a = x * (( ld ) y / z ), b = x * y - a * z ; if ( b < 0 ) b += z ; if ( b >= z ) b -= z ; return b ; } inline int add ( int x , int y , int z ){ return x + y >= z ? x + y - z : x + y ;} inline int power ( int x , int y , int z ) { int s = 1 ; for (; y ; y >>= 1 , x = mul ( x , x , z )) if ( y & 1 ) s = mul ( s , x , z ); return s ; } inline bool chk ( int n ) { if ( n < 3 || n % 2 == 0 ) return n == 2 ; int u = n -1 , t = 0 ; while ( u % 2 == 0 ) u /= 2 , ++ t ; for ( int i = 0 , s , a , v ; i < 8 ; ++ i ) { a = rd ( 2 , n -1 ), v = power ( a , u , n ); if ( v == 1 ) continue ; for ( s = 0 ; s < t ; ++ s ) { if ( v == n -1 ) break ; v = mul ( v , v , n ); } if ( s == t ) return 0 ; } return 1 ; } #define nx(a) add(mul(a,a,n),c,n) inline int gcd ( int a , int b ) { int az = __builtin_ctzll ( a ), bz = __builtin_ctzll ( b ); int z = min ( az , bz ), tmp ; b >>= bz ; while ( a ) a >>= az , tmp = a - b , az = __builtin_ctzll ( tmp ), b = min ( a , b ), a = abs ( tmp ); return b << z ; } int calc ( int n ) { if ( n == 4 ) return 2 ; int x = rd ( 3 , n -1 ), y = x , c = rd ( 3 , n -1 ), d = 1 ; x = nx ( x ), y = nx ( nx ( y )); for ( int lim = 1 ; x != y ; lim = min ( 128l l , lim << 1 )) { int cnt = 1 ; for ( int i = 0 ; i < lim ; ++ i ) { int tmp = mul ( cnt , abs ( x - y ), n ); if ( ! tmp ) break ; cnt = tmp , x = nx ( x ), y = nx ( nx ( y )); } d = gcd ( cnt , n ); if ( d > 1 ) return d ; } return n ; } vi ve ; void dfs ( int n ) { if ( n == 1 ) return ; int d = calc ( n ), d2 ; while ( d == n ) d = calc ( n ); d2 = n / d ; if ( chk ( d )) ve . eb ( d ); else dfs ( d ); if ( chk ( d2 )) ve . eb ( d2 ); else dfs ( d2 ); }","title":"Pollardrho"},{"location":"Math/number%20theory/sieve/dusieve/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 unordered_map < int , ll > phi ; unordered_map < int , int > mu ; ll PHI [ 20000001 ]; int MU [ 20000001 ], prime [ 10000001 ], cnt , T , n ; bool v [ 20000001 ]; inline int read () { int ans = 0 ; char ch = getchar (); while (( ch > '9' ) || ( ch < '0' )) ch = getchar (); while (( ch >= '0' ) && ( ch <= '9' )) ans = ans * 10 + ch - '0' , ch = getchar (); return ans ; } ll askphi ( int k ) { if ( k <= 20000000 ) return PHI [ k ]; if ( phi [ k ]) return phi [ k ]; ll sum = k * ( k + 1 ) / 2 ; for ( int l = 2 , r ; l <= k ; l = r + 1 ) r = k / ( k / l ), sum -= ( r - l + 1 ) * askphi ( k / l ); return phi [ k ] = sum ; } int askmu ( int k ) { if ( k <= 20000000 ) return MU [ k ]; if ( mu [ k ]) return mu [ k ]; int sum = 1 ; for ( int l = 2 , r ; l <= k ; l = r + 1 ) r = k / ( k / l ), sum -= ( r - l + 1 ) * askmu ( k / l ); return mu [ k ] = sum ; } inline void sieve () { MU [ 1 ] = 1 , PHI [ 1 ] = 1 ; for ( int i = 2 ; i <= 20000000 ; ++ i ) { if ( ! v [ i ]) prime [ ++ cnt ] = i , PHI [ i ] = i -1 , MU [ i ] = -1 ; for ( int j = 1 ; j <= cnt ; ++ j ) { if ( i * prime [ j ] > 20000000 ) break ; v [ prime [ j ] * i ] = 1 ; if ( i % prime [ j ] == 0 ){ PHI [ i * prime [ j ]] = PHI [ i ] * prime [ j ], MU [ i * prime [ j ]] = 0 ; break ;} PHI [ prime [ j ] * i ] = PHI [ i ] * ( prime [ j ] -1 ), MU [ i * prime [ j ]] =- MU [ i ]; } PHI [ i ] += PHI [ i -1 ], MU [ i ] += MU [ i -1 ]; } }","title":"Dusieve"},{"location":"Math/number%20theory/sieve/min25sieve/","text":"\u7b5b\u7684\u662f \\(f(p^k)=p^k(p^k-1)\\) \u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 ll n , w [ 300010 ], g1 [ 300010 ], g2 [ 300010 ], sum1 [ 300010 ], sum2 [ 300010 ], pr [ 300010 ]; int N , m , cnt , id1 [ 300010 ], id2 [ 300010 ], iv6 ; bool v [ 300010 ]; inline void preSieve () { for ( int i = 2 ; i <= N ; ++ i ) { if ( ! v [ i ]) pr [ ++ cnt ] = i ; for ( int j = 1 ; j <= cnt && pr [ j ] * i <= N ; ++ j ) { v [ pr [ j ] * i ] = 1 ; if ( i % pr [ j ] == 0 ) break ;} } for ( int i = 1 ; i <= cnt ; ++ i ) { sum1 [ i ] = Cadd ( sum1 [ i -1 ], pr [ i ]); sum2 [ i ] = ( sum2 [ i -1 ] + 1l l * pr [ i ] * pr [ i ]) % MOD ; } } inline int f1 ( ll x ){ x %= MOD ; return x * ( x + 1 ) / 2 % MOD ;} inline int f2 ( ll x ){ x %= MOD ; return x * ( x + 1 ) % MOD * ( 2 * x + 1 ) % MOD * iv6 % MOD ;} inline int getid ( ll x ){ return x <= N ? id1 [ x ] : id2 [ n / x ];} ll S ( ll x , int j ) { if ( pr [ j ] > x ) return 0 ; ll ans = Cdel ( Cdel ( g2 [ getid ( x )], g1 [ getid ( x )]), Cdel ( sum2 [ j ], sum1 [ j ])); for ( int i = j + 1 ; i <= cnt && pr [ i ] * pr [ j ] <= x ; ++ i ) { for ( ll e = 1 , sp = pr [ i ]; sp <= x ; sp *= pr [ i ], ++ e ) ans = ( ans + sp % MOD * ( sp % MOD -1 ) % MOD * ( S ( x / sp , i ) + ( e > 1 ))) % MOD ; } return ans ; } inline ll sieve () { N = sqrt ( n ), preSieve (), iv6 = power ( 6 , MOD -2 ); for ( ll l = 1 , r ; l <= n ; l = r + 1 ) { r = n / ( n / l ), w [ ++ m ] = n / l ; g1 [ m ] = f1 ( w [ m ]) -1 , g2 [ m ] = f2 ( w [ m ]) -1 ; if ( w [ m ] <= N ) id1 [ w [ m ]] = m ; else id2 [ n / w [ m ]] = m ; } for ( int i = 1 ; i <= cnt ; ++ i ) { for ( int j = 1 ; j <= m && pr [ i ] * pr [ i ] <= w [ j ]; ++ j ) { g1 [ j ] = (( g1 [ j ] -1ll * pr [ i ] * ( g1 [ getid ( w [ j ] / pr [ i ])] - sum1 [ i -1 ])) % MOD + MOD ) % MOD ; g2 [ j ] = (( g2 [ j ] -1ll * pr [ i ] * pr [ i ] % MOD * ( g2 [ getid ( w [ j ] / pr [ i ])] - sum2 [ i -1 ])) % MOD + MOD ) % MOD ; } } return S ( n , 0 ) + 1 ; }","title":"Min25sieve"},{"location":"String/ACAM/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 int f [ 200001 ], trie [ 200001 ][ 26 ], cnt , fail [ 200001 ], head [ 200001 ], to [ 200001 ], nex [ 200001 ], tot ; queue < int > q ; inline void add ( int x , int y ){ to [ ++ tot ] = y , nex [ tot ] = head [ x ], head [ x ] = tot ;} inline void init (){ memset ( trie , 0 , sizeof ( trie )), memset ( f , 0 , sizeof ( f )), memset ( head , 0 , sizeof ( head )), tot = 0 , cnt = 1 ;} inline void insert ( int id ) { int now = 1 ; for ( int i = 1 ; i <= len ; ++ i ) { if ( ! trie [ now ][ s [ i ] - 'a' ]) trie [ now ][ s [ i ] - 'a' ] =++ cnt ; now = trie [ now ][ s [ i ] - 'a' ]; } end [ id ] = now ; } inline void build () { q . emplace ( 1 ); for ( int i = 0 ; i < 26 ; ++ i ) trie [ 0 ][ i ] = 1 ; while ( ! q . empty ()) { int now = q . front (); q . pop (); for ( int i = 0 ; i < 26 ; ++ i ) { if ( trie [ now ][ i ]) fail [ trie [ now ][ i ]] = trie [ fail [ now ]][ i ], add ( trie [ fail [ now ]][ i ], trie [ now ][ i ]), q . emplace ( trie [ now ][ i ]); else trie [ now ][ i ] = trie [ fail [ now ]][ i ]; } } }","title":"AC \u81ea\u52a8\u673a"},{"location":"String/GSAM/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 int pos [ 1000010 ]; char s [ 1000010 ]; namespace Trie { int trie [ 1000010 ][ 26 ], tot = 1 ; inline void insert () { int now = 1 , n = strlen ( s ); for ( int i = 0 ; i < n ; ++ i ) { if ( ! trie [ now ][ s [ i ] - 'a' ]) trie [ now ][ s [ i ] - 'a' ] =++ tot ; now = trie [ now ][ s [ i ] - 'a' ]; } } } using namespace Trie ; int cnt = 1 ; struct { int ch [ 26 ], fa , len ;} t [ 2000010 ]; inline int add ( int x , int last ) { int np =++ cnt , p = last , q , nq ; t [ np ]. len = t [ p ]. len + 1 ; while ( ! t [ p ]. ch [ x ]) t [ p ]. ch [ x ] = np , p = t [ p ]. fa ; if ( t [ q = t [ p ]. ch [ x ]]. len == t [ p ]. len + 1 ) return t [ np ]. fa = q , np ; t [ nq =++ cnt ] = t [ q ], t [ nq ]. len = t [ p ]. len + 1 , t [ np ]. fa = t [ q ]. fa = nq ; while ( p && t [ p ]. ch [ x ] == q ) t [ p ]. ch [ x ] = nq , p = t [ p ]. fa ; return np ; } queue < int > q ; void build () { for ( int i = 0 ; i < 26 ; ++ i ) t [ 0 ]. ch [ i ] = 1 ; t [ 0 ]. len = -1 ; q . e ( 1 ), pos [ 1 ] = 1 ; while ( ! q . empty ()) { int now = q . front (); q . pop (); for ( int i = 0 ; i < 26 ; ++ i ) { if ( trie [ now ][ i ]) pos [ trie [ now ][ i ]] = add ( i , pos [ now ]), q . e ( trie [ now ][ i ]); } } }","title":"\u5e7f\u4e49\u540e\u7f00\u81ea\u52a8\u673a"},{"location":"String/SA/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 int n , maxn , m = 128 , F [ 21 ][ 1000001 ], sa [ 1000001 ], rk [ 1000001 ], b [ 1000001 ], x [ 1000001 ], y [ 1000001 ]; char s [ 250001 ]; inline int ask ( int x , int y ) { if ( x == y ) return inf ; if (( x = rk [ x ]) > ( y = rk [ y ])) swap ( x , y ); int k = __lg ( y - x ++ ); return min ( F [ k ][ x ], F [ k ][ y - ( 1 << k ) + 1 ]); } inline void SA () { scanf ( \"%s\" , s + 1 ), n = strlen ( s + 1 ); for ( int i = 1 ; i <= n ; ++ i ) ++ b [ x [ i ] = s [ i ]]; for ( int i = 2 ; i <= m ; ++ i ) b [ i ] += b [ i -1 ]; for ( int i = 1 ; i <= n ; ++ i ) sa [ b [ x [ i ]] -- ] = i ; for ( int k = 1 , num = 0 ; k <= n ; k <<= 1 , num = 0 ) { for ( int i = n - k + 1 ; i <= n ; ++ i ) y [ ++ num ] = i ; for ( int i = 1 ; i <= n ; ++ i ) if ( sa [ i ] > k ) y [ ++ num ] = sa [ i ] - k ; for ( int i = 1 ; i <= m ; ++ i ) b [ i ] = 0 ; for ( int i = 1 ; i <= n ; ++ i ) ++ b [ x [ i ]]; for ( int i = 2 ; i <= m ; ++ i ) b [ i ] += b [ i -1 ]; for ( int i = n ; i >= 1 ; -- i ) sa [ b [ x [ y [ i ]]] -- ] = y [ i ]; swap ( x , y ), x [ sa [ 1 ]] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) { if ( y [ sa [ i ]] == y [ sa [ i -1 ]] && y [ sa [ i ] + k ] == y [ sa [ i -1 ] + k ]) x [ sa [ i ]] = x [ sa [ i -1 ]]; else x [ sa [ i ]] = x [ sa [ i -1 ]] + 1 ; } if (( m = x [ sa [ n ]]) == n ) break ; } for ( int i = 1 ; i <= n ; ++ i ) rk [ sa [ i ]] = i ; for ( int i = 1 , k = 0 ; i <= n ; ++ i , k ?-- k : 0 ) { while ( s [ i + k ] == s [ sa [ rk [ i ] -1 ] + k ]) ++ k ; F [ 0 ][ rk [ i ]] = k ; } for ( int i = 1 ; i <= 20 ; ++ i ) { for ( int j = 1 ; j + ( 1 << i ) -1 <= n ; ++ j ) F [ i ][ j ] = min ( F [ i -1 ][ j ], F [ i -1 ][ j + ( 1 << ( i -1 ))]); } }","title":"\u540e\u7f00\u6570\u7ec4"},{"location":"String/SAM/","text":"\u6a21\u677f\u9898\u7684\u4f8b\u5b50\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int last = 1 , cnt = 1 ; struct { int ch [ 26 ], fa , len ;} t [ 2000010 ]; inline void add ( int x ) { int np =++ cnt , p = last , q , nq ; t [ last = np ]. len = t [ p ]. len + 1 , f [ np ] = 1 ; while ( p &&! t [ p ]. ch [ x ]) t [ p ]. ch [ x ] = np , p = t [ p ]. fa ; if ( ! p ) return t [ np ]. fa = 1 , void (); if ( t [ q = t [ p ]. ch [ x ]]. len == t [ p ]. len + 1 ) return t [ np ]. fa = q , void (); t [ nq =++ cnt ] = t [ q ], t [ nq ]. len = t [ p ]. len + 1 , t [ np ]. fa = t [ q ]. fa = nq ; while ( p && t [ p ]. ch [ x ] == q ) t [ p ]. ch [ x ] = nq , p = t [ p ]. fa ; } void dfs ( int x ){ for ( auto to : T [ x ]) dfs ( to ), f [ x ] += f [ to ]; if ( f [ x ] > 1 ) Mmax ( ans , 1l l * f [ x ] * t [ x ]. len );} inline void mian () { char ch ; while (( ch = getchar ()) != '\\n' ) add ( ch - 'a' ); for ( int i = 2 ; i <= cnt ; ++ i ) T [ t [ i ]. fa ]. eb ( i ); dfs ( 1 ), write ( ans ); }","title":"\u540e\u7f00\u81ea\u52a8\u673a"},{"location":"String/manacher/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 char s [ 11000005 ]; int n , d1 [ 11000005 ], d2 [ 11000005 ]; inline void manacher () { n = strlen ( s + 1 ); for ( int i = 1 , l = 1 , r = 0 ; i <= n ; ++ i ) { int k = ( i > r ) ? 1 : min ( d1 [ l + r - i ], r - i + 1 ); while (( 0 <= i - k ) && ( i + k <= n ) && ( s [ i + k ] == s [ i - k ])) k ++ ; d1 [ i ] = k -- ; if ( i + k > r ) r = i + k , l = i - k ; } for ( int i = 1 , l = 1 , r = 0 ; i <= n ; ++ i ) { int k = ( i > r ) ? 0 : min ( d2 [ l + r - i + 1 ], r - i + 1 ); while (( 0 < i - k ) && ( i + k <= n ) && ( s [ i - k -1 ] == s [ i + k ])) k ++ ; d2 [ i ] = k -- ; if ( i + k > r ) r = i + k , l = i - k -1 ; } }","title":"manacher"},{"location":"%E7%BC%BA%E7%9C%81%E6%BA%90/%E7%BC%BA%E7%9C%81%E6%BA%90/","text":"\u7f16\u8bd1\u9009\u9879\uff1a -lm -Wall -Wl,--stack=10240000 -std=c++14 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <bits/stdc++.h> #define ull unsigned long long #define ui unsigned int #define ld long double #define ll long long #define lll __int128 #define fi first #define se second #define e emplace #define eb emplace_back #define db double #define ef emplace_front #define pii pair<int,int> #define pll pair<ll,ll> #define vi vector<int> #define vp vector<pii> #define mp make_pair //#define LOCALJUDGE #define int ll bool ST ; static const ll MOD = 1e9 + 7 , Phi = 998244352 , inv2 = 499122177 , Root = 3 , iRoot = 332748118 ; static const ll inf = 1073741823 , INF = 4557430888798830399 ; static const ld eps = 1e-11 , pi = 3.1415926535 ; char in [ 1 << 20 ], * p1 = in , * p2 = in ; using namespace std ; //#define getchar() (p1==p2&&(p2=(p1=in)+fread(in,1,1<<20,stdin),p1==p2)?EOF:*p1++) struct tup { int x , y , z ; tup ( int X = 0 , int Y = 0 , int Z = 0 ){ x = X , y = Y , z = Z ;}}; namespace FastIO { template < typename T > inline void write ( T x , char ch = ' ' ) { if ( is_same < char , T >:: value ) putchar ( x ); else { if ( x < 0 ) x =- x , putchar ( '-' ); static char st [ 25 ]; int top = 0 ; do { st [ top ++ ] = x % 10 + '0' , x /= 10 ;} while ( x ); while ( top ) putchar ( st [ -- top ]); } ch != '~' ? putchar ( ch ) : 0 ; } inline void write ( const char * x , char ch = ' ' ) { for ( int i = 0 ; x [ i ] != '\\0' ; ++ i ) putchar ( x [ i ]); ch != '~' ? putchar ( ch ) : 0 ; } inline void read ( char & s ){ do s = getchar (); while ( s == '\\n' || s == ' ' );} inline void read ( char s []) { int len = 0 ; char st ; do st = getchar (); while ( st == '\\n' || st == ' ' ); s [ ++ len ] = st , st = getchar (); while ( st != '\\n' && st != ' ' && st != '\\r' ) s [ ++ len ] = st , st = getchar (); s [ ++ len ] = '\\0' ; } template < typename T > inline void read ( T & s ) { s = 0 ; char ch = getchar (); while (( ch > '9' || ch < '0' ) && ch != '-' ) ch = getchar (); bool tf = ( ch == '-' ) && ( ch = getchar ()); while (( ch >= '0' ) && ( ch <= '9' )) s = ( s << 1 ) + ( s << 3 ) + ch - '0' , ch = getchar (); s = ( tf ?- s : s ); } template < typename T1 , typename T2 > inline void read ( pair < T1 , T2 > & s ){ read ( s . fi ), read ( s . se );} template < typename T , typename ... Args > inline void write ( T x , Args ... args ){ write ( x , '~' ), write ( args ...);} template < typename T , typename ... Args > inline void read ( T & x , Args & ... args ){ read ( x ), read ( args ...);} } using namespace FastIO ; namespace MTool { inline int Cadd ( int a , int b ){ return ( ll ) a + b >= MOD ? ( ll ) a + b - MOD : a + b ;} inline int Cdel ( int a , int b ){ return a - b < 0 ? a - b + MOD : a - b ;} inline int Cmul ( int a , int b ){ return 1l l * a * b % MOD ;} inline int sqr ( int a ){ return 1l l * a * a % MOD ;} inline void Madd ( int & a , int b ){ a = (( ll ) a + b >= MOD ? ( ll ) a + b - MOD : a + b );} inline void Mdel ( int & a , int b ){ a = ( a - b < 0 ? a - b + MOD : a - b );} inline void Mmul ( int & a , int b ){ a = 1l l * a * b % MOD ;} template < typename T > inline bool Mmax ( T & a , T b ){ return a < b ? a = b , 1 : 0 ;} template < typename T > inline bool Mmin ( T & a , T b ){ return a > b ? a = b , 1 : 0 ;} template < typename ... Args > inline void Madd ( int & a , int b , Args ... args ){ Madd ( a , b ), Madd ( a , args ...);} template < typename ... Args > inline void Mmul ( int & a , int b , Args ... args ){ Mmul ( a , b ), Mmul ( a , args ...);} template < typename ... Args > inline void Mdel ( int & a , int b , Args ... args ){ Mdel ( a , b ), Mdel ( a , args ...);} template < typename ... Args > inline int Cadd ( int a , int b , Args ... args ){ return Cadd ( Cadd ( a , b ), args ...);} template < typename ... Args > inline int Cmul ( int a , int b , Args ... args ){ return Cmul ( Cmul ( a , b ), args ...);} template < typename ... Args > inline int Cdel ( int a , int b , Args ... args ){ return Cdel ( Cdel ( a , b ), args ...);} template < typename ... Args , typename T > inline bool Mmax ( T & a , T b , Args ... args ){ return Mmax ( a , b ) | Mmax ( a , args ...);} template < typename ... Args , typename T > inline bool Mmin ( T & a , T b , Args ... args ){ return Mmin ( a , b ) | Mmin ( a , args ...);} inline int power ( int x , int y ){ int s = 1 ; for (; y ; y >>= 1 , Mmul ( x , x )) if ( y & 1 ) Mmul ( s , x ); return s ;} } using namespace MTool ; namespace WrongAnswer_90 { inline void mian () { } } bool ED ; signed main () { #ifdef LOCALJUDGE freopen ( \"1.in\" , \"r\" , stdin ); freopen ( \"1.out\" , \"w\" , stdout ); #endif double st = clock (); WrongAnswer_90 :: mian (); double ed = clock (); #ifndef LOCALJUDGE cerr << endl ; #endif cerr << \"Time: \" << ed - st << \" ms \\n \" ; #ifdef LOCALJUDGE cerr << \" \" ; #endif cerr << \"Memory: \" << abs ( & ST -& ED ) / 1024.0 / 1024.0 << \" MB \\n \" ; return 0 ; }","title":"\u7f3a\u7701\u6e90"}]}