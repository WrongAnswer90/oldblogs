{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u8fd9\u91cc\u662f WA90 \u7684\u4ee3\u7801\u4ed3\u5e93\uff0c\u90e8\u5206\u6a21\u677f\u9700\u8981\u642d\u914d \u7f3a\u7701\u6e90 \u4f7f\u7528 QQ\uff1a2609493041 \u6b22\u8fce\u8054\u7cfb\u3002","title":"Home"},{"location":"%E7%BC%BA%E7%9C%81%E6%BA%90/","text":"\u7f16\u8bd1\u9009\u9879\uff1a -lm -Wall -Wl,--stack=10240000 -std=c++20 -O2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 #include <bits/stdc++.h> #define ull unsigned long long #define ui unsigned int #define ld long double #define ll long long #define lll __int128 #define fi first #define se second #define e emplace #define eb emplace_back #define db double #define ef emplace_front #define pii pair<int,int> #define pll pair<ll,ll> #define vi vector<int> #define vp vector<pii> #define vt vector<tup> #define all(x) x.begin(),x.end() #define mp make_pair #define FastI #define FastO //#define int ll bool ST ; static const ll MOD = 998244353 , Phi = 998244352 , inv2 = 499122177 , Root = 3 , iRoot = 332748118 ; static const ll inf = 1073741823 , Inf = 4294967296 , INF = 4557430888798830399 ; static const ld eps = 1e-9 , pi = 3.1415926535 ; char in [ 1 << 20 ], * p1 = in , * p2 = in ; char out [ 1 << 20 ], * p3 = out ; using namespace std ; struct tup { int x , y , z ; tup ( int X = 0 , int Y = 0 , int Z = 0 ) { x = X , y = Y , z = Z ;} }; #ifdef FastI #define getchar() (p1==p2&&(p2=(p1=in)+fread(in,1,1<<20,stdin),p1==p2)?EOF:*p1++) #endif #ifdef FastO #define putchar(x) (p3-out==1<<20?fwrite(out,1,1<<20,stdout),p3=out,0:0,*p3++=x) #define puts(x) write(x,'\\n') #endif namespace FastIO { template < typename T > inline void write ( T x , char ch = ' ' ) { if ( is_same < char , T >:: value ) putchar ( x ); else { if ( x < 0 ) x =- x , putchar ( '-' ); static char st [ 25 ]; int top = 0 ; do st [ top ++ ] = x % 10 + '0' , x /= 10 ; while ( x ); while ( top ) putchar ( st [ -- top ]); } ch != '~' ? putchar ( ch ) : 0 ; } inline void write ( const char * x , char ch = ' ' ) { for ( int i = 0 ; x [ i ] != '\\0' ; ++ i ) putchar ( x [ i ]); ch != '~' ? putchar ( ch ) : 0 ; } inline void read ( char & s ){ do s = getchar (); while ( s == '\\n' || s == ' ' );} inline void read ( char s []) { int len = 0 ; char st ; do st = getchar (); while ( st == '\\n' || st == ' ' ); s [ ++ len ] = st , st = getchar (); while ( st != '\\n' && st != ' ' ) s [ ++ len ] = st , st = getchar (); s [ ++ len ] = '\\0' ; } template < typename T > inline void read ( T & s ) { char ch = getchar (); s = 0 ; while (( ch > '9' || ch < '0' ) && ch != '-' ) ch = getchar (); bool tf = ( ch == '-' && ( ch = getchar ())); while ( ch >= '0' && ch <= '9' ) s = ( s << 1 ) + ( s << 3 ) + ch - '0' , ch = getchar (); s = tf ?- s : s ; } inline void edl (){ putchar ( '\\n' );} template < typename T1 , typename T2 > inline void read ( pair < T1 , T2 > & s ){ read ( s . fi ), read ( s . se );} template < typename T , typename ... Args > inline void write ( T x , Args ... args ){ write ( x , '~' ), write ( args ...);} template < typename T , typename ... Args > inline void read ( T & x , Args & ... args ){ read ( x ), read ( args ...);} #ifdef FastO struct Writer { ~ Writer (){ fwrite ( out , 1 , p3 - out , stdout );}} Writ ; #endif } using namespace FastIO ; namespace MTool { inline int Cadd ( int a , int b ){ return ( ll ) a + b >= MOD ? ( ll ) a + b - MOD : a + b ;} inline int Cdel ( int a , int b ){ return a - b < 0 ? a - b + MOD : a - b ;} inline int Cmul ( int a , int b ){ return 1l l * a * b % MOD ;} inline int sqr ( int a ){ return 1l l * a * a % MOD ;} inline void Madd ( int & a , int b ){ a = (( ll ) a + b >= MOD ? ( ll ) a + b - MOD : a + b );} inline void Mdel ( int & a , int b ){ a = ( a - b < 0 ? a - b + MOD : a - b );} inline void Mmul ( int & a , int b ){ a = 1l l * a * b % MOD ;} inline int Cmod ( int x ){ return ( x % MOD + MOD ) % MOD ;} inline void Mmod ( int & x ){ x = ( x % MOD + MOD ) % MOD ;} template < typename T > inline bool Mmax ( T & a , T b ){ return a < b ? a = b , 1 : 0 ;} template < typename T > inline bool Mmin ( T & a , T b ){ return a > b ? a = b , 1 : 0 ;} template < typename ... Args > inline void Madd ( int & a , int b , Args ... args ){ Madd ( a , b ), Madd ( a , args ...);} template < typename ... Args > inline void Mmul ( int & a , int b , Args ... args ){ Mmul ( a , b ), Mmul ( a , args ...);} template < typename ... Args > inline void Mdel ( int & a , int b , Args ... args ){ Mdel ( a , b ), Mdel ( a , args ...);} template < typename ... Args > inline int Cadd ( int a , int b , Args ... args ){ return Cadd ( Cadd ( a , b ), args ...);} template < typename ... Args > inline int Cmul ( int a , int b , Args ... args ){ return Cmul ( Cmul ( a , b ), args ...);} template < typename ... Args > inline int Cdel ( int a , int b , Args ... args ){ return Cdel ( Cdel ( a , b ), args ...);} template < typename ... Args , typename T > inline bool Mmax ( T & a , T b , Args ... args ){ return Mmax ( a , b ) | Mmax ( a , args ...);} template < typename ... Args , typename T > inline bool Mmin ( T & a , T b , Args ... args ){ return Mmin ( a , b ) | Mmin ( a , args ...);} inline int power ( int x , int y ){ int s = 1 ; for (; y ; y >>= 1 , Mmul ( x , x )) if ( y & 1 ) Mmul ( s , x ); return s ;} } using namespace MTool ; namespace WrongAnswer_90 { inline void mian () { } inline void Mian () { int T = 1 ; // read(T); while ( T -- ) mian (); } } bool ED ; signed main () { freopen ( \"1.in\" , \"r\" , stdin ); freopen ( \"1.out\" , \"w\" , stdout ); double st = clock (); WrongAnswer_90 :: Mian (); double ed = clock (); cerr << endl ; cerr << \"Time: \" << ed - st << \" ms \\n \" ; cerr << \"Memory: \" << abs ( & ST -& ED ) / 1024.0 / 1024.0 << \" MB \\n \" ; return 0 ; }","title":"\u7f3a\u7701\u6e90"},{"location":"DS/FHQ/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 struct Node { int l , r , size , rd , val , tag ;} fhq [ 200001 ]; int n , cnt , m , root ; inline void update ( int x ){ fhq [ x ]. size = fhq [ fhq [ x ]. l ]. size + fhq [ fhq [ x ]. r ]. size + 1 ;} inline int newnode ( int val ){ fhq [ ++ cnt ]. val = val , fhq [ cnt ]. rd = rand () % 11451419 , fhq [ cnt ]. size = 1 ; return cnt ;} inline void spread ( int x ) { if ( fhq [ x ]. tag ) { swap ( fhq [ x ]. l , fhq [ x ]. r ); fhq [ fhq [ x ]. l ]. tag ^= 1 , fhq [ fhq [ x ]. r ]. tag ^= 1 ; fhq [ x ]. tag = 0 ; } } void split ( int now , int rank , int & x , int & y ) { if ( ! now ){ x = y = 0 ; return ;} spread ( now ); if ( fhq [ fhq [ now ]. l ]. size >= rank ) y = now , split ( fhq [ now ]. l , rank , x , fhq [ now ]. l ); else x = now , split ( fhq [ now ]. r , rank - fhq [ fhq [ now ]. l ]. size -1 , fhq [ now ]. r , y ); update ( now ); } int merge ( int x , int y ) { if ( ! x ||! y ) return x + y ; if ( fhq [ x ]. rd > fhq [ y ]. rd ){ spread ( x ), fhq [ x ]. r = merge ( fhq [ x ]. r , y ), update ( x ); return x ;} else { spread ( y ), fhq [ y ]. l = merge ( x , fhq [ y ]. l ), update ( y ); return y ;} }","title":"fhq treap"},{"location":"DS/KDT/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 struct Node { int v , sum , ls , rs , x [ 2 ], L [ 2 ], R [ 2 ]; Node ( int X = 0 , int Y = 0 , int Z = 0 ){ x [ 0 ] = X , x [ 1 ] = Y , v = Z ;}} t [ 200010 ], l , r ; int ans , n , cnt , root [ 18 ], b [ 200010 ]; #define ls(x) t[x].ls #define rs(x) t[x].rs inline void update ( int p ) { t [ p ]. sum = t [ ls ( p )]. sum + t [ rs ( p )]. sum + t [ p ]. v ; for ( int k = 0 ; k < 2 ; ++ k ) { t [ p ]. L [ k ] = t [ p ]. R [ k ] = t [ p ]. x [ k ]; if ( ls ( p )) Mmin ( t [ p ]. L [ k ], t [ ls ( p )]. L [ k ]), Mmax ( t [ p ]. R [ k ], t [ ls ( p )]. R [ k ]); if ( rs ( p )) Mmin ( t [ p ]. L [ k ], t [ rs ( p )]. L [ k ]), Mmax ( t [ p ]. R [ k ], t [ rs ( p )]. R [ k ]); } } inline bool cmpx ( int x , int y ){ return t [ x ]. x [ 0 ] < t [ y ]. x [ 0 ];} inline bool cmpy ( int x , int y ){ return t [ x ]. x [ 1 ] < t [ y ]. x [ 1 ];} int build ( int l , int r , int dep = 0 ) { int mid = l + (( r - l ) >> 1 ); nth_element ( b + l , b + mid , b + r + 1 , dep ? cmpx : cmpy ); int x = b [ mid ]; if ( l < mid ) ls ( x ) = build ( l , mid -1 , dep ^ 1 ); if ( mid < r ) rs ( x ) = build ( mid + 1 , r , dep ^ 1 ); return update ( x ), x ; } void append ( int & p ){ if ( p ) b [ ++ cnt ] = p , append ( ls ( p )), append ( rs ( p )), p = 0 ;} int query ( int p ) { if ( ! p ) return 0 ; bool flag = 1 ; for ( int k = 0 ; k < 2 ; ++ k ) flag &= l . x [ k ] <= t [ p ]. L [ k ] && r . x [ k ] >= t [ p ]. R [ k ]; if ( flag ) return t [ p ]. sum ; for ( int k = 0 ; k < 2 ; ++ k ) if ( t [ p ]. R [ k ] < l . x [ k ] || t [ p ]. L [ k ] > r . x [ k ]) return 0 ; flag = 1 ; for ( int k = 0 ; k < 2 ; ++ k ) flag &= l . x [ k ] <= t [ p ]. x [ k ] && r . x [ k ] >= t [ p ]. x [ k ]; return flag * t [ p ]. v + query ( ls ( p )) + query ( rs ( p )); } inline void ins ( int x , int y , int z ) { t [ ++ n ] = Node ( x , y , z ), b [ cnt = 1 ] = n ; for ( int i = 0 ;; ++ i ) { if ( ! root [ i ]){ root [ i ] = build ( 1 , cnt ); break ;} else append ( root [ i ]); } }","title":"K-D tree"},{"location":"DS/LCT/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 namespace Splay { struct { int fa , ch [ 2 ], val , siz , sum ; bool tag ;} spl [ 1000001 ]; #define ls(x) (spl[x].ch[0]) #define rs(x) (spl[x].ch[1]) #define fa(x) (spl[x].fa) #define ident(x,f) (rs(f)==x) #define connect(x,f,s) (spl[fa(x)=f].ch[s]=x) #define update(x) (spl[x].siz=spl[ls(x)].siz+spl[rs(x)].siz+1,spl[x].sum=spl[ls(x)].sum^spl[rs(x)].sum^spl[x].val) #define ntroot(x) ((ls(fa(x))==x)||(rs(fa(x))==x)) #define down(x) (swap(ls(x),rs(x)),spl[x].tag^=1) inline void spread ( int k ) { if ( spl [ k ]. tag ) down ( ls ( k )), down ( rs ( k )); spl [ k ]. tag = 0 ; } void pushall ( int x ){ if ( ntroot ( x )) pushall ( fa ( x )); spread ( x );} inline void rotate ( int x ) { int f = fa ( x ), ff = fa ( f ), s = ident ( x , f ); if ( ntroot ( f )) spl [ ff ]. ch [ ident ( f , ff )] = x ; connect ( spl [ x ]. ch [ s ^ 1 ], f , s ), fa ( x ) = ff , connect ( f , x , s ^ 1 ), update ( f ), update ( x ); } inline void splaying ( int x ) { pushall ( x ); while ( ntroot ( x )) { int f = fa ( x ), ff = fa ( f ); if ( ntroot ( f ))( ident ( x , f ) ^ ident ( f , ff )) ? rotate ( x ) : rotate ( f ); rotate ( x ); } } } using namespace Splay ; inline void access ( int x ){ for ( int y = 0 ; x ; x = fa ( y = x )) splaying ( x ), rs ( x ) = y , update ( x );} inline void mkroot ( int x ){ access ( x ), splaying ( x ), down ( x );} inline int findroot ( int x ) { access ( x ), splaying ( x ), spread ( x ); while ( ls ( x )) x = ls ( x ), spread ( x ); splaying ( x ); return x ; } inline void link ( int x , int y ) { mkroot ( x ); if ( findroot ( y ) == x ) return ; fa ( x ) = y ; } inline void cut ( int x , int y ) { mkroot ( x ); if ( findroot ( y ) != x || fa ( y ) != x || ls ( y )) return ; fa ( y ) = rs ( x ) = 0 , update ( x ); } inline void split ( int x , int y ){ mkroot ( x ), access ( y ), splaying ( y );}","title":"\u52a8\u6001\u6811"},{"location":"DS/LTT/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 struct { int l , r , fa , val , dis ;} t [ 300001 ]; int find ( int x ){ return x == t [ x ]. fa ? x : t [ x ]. fa = find ( t [ x ]. fa );} int merge ( int x , int y ) { if ( ! x ||! y ) return x | y ; if ( t [ x ]. val > t [ y ]. val || ( t [ x ]. val == t [ y ]. val && x > y )) swap ( x , y ); t [ x ]. r = merge ( t [ x ]. r , y ); t [ t [ x ]. r ]. fa = x ; if ( t [ t [ x ]. l ]. dis < t [ t [ x ]. r ]. dis ) swap ( t [ x ]. l , t [ x ]. r ); t [ x ]. dis = t [ t [ x ]. r ]. dis + 1 ; return x ; } inline void pop ( int x ){ t [ x ]. val = -1 , t [ t [ x ]. l ]. fa = t [ t [ x ]. r ]. fa = t [ x ]. fa = t [ x ]. l = merge ( t [ x ]. l , t [ x ]. r );}","title":"\u53ef\u5e76\u5806"},{"location":"DS/LiCT/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 struct LiCT { #define pdi pair<double,int> struct { double k , b ;} p [ 600001 ]; struct { int l , r , best ;} t [ 800001 ]; int cnt ; inline int cmp ( double x , double y ){ return x - y > eps ? 1 : y - x > eps ? -1 : 0 ;} inline double calc ( int id , int x ){ return x * p [ id ]. k + p [ id ]. b ;} void build ( int p , int l , int r ) { t [ p ]. l = l , t [ p ]. r = r ; if ( l == r ) return ; int mid = l + (( r - l ) >> 1 ); build ( p * 2 , l , mid ), build ( p * 2 + 1 , mid + 1 , r ); } inline void add ( int x0 , int y0 , int x1 , int y1 ) { if ( x0 == x1 ) ++ cnt , p [ cnt ]. k = 0 , p [ cnt ]. b = max ( y0 , y1 ); else ++ cnt , p [ cnt ]. k = 1.0 * ( y0 - y1 ) / ( x0 - x1 ), p [ cnt ]. b = ( double ) y0 - ( double ) x0 * p [ cnt ]. k ; } void update ( int p , int u ) { int & v = t [ p ]. best ; int mid = t [ p ]. l + t [ p ]. r >> 1 ; int dl = cmp ( calc ( u , mid ), calc ( v , mid )); if ( dl == 1 || ( dl == 0 && u < v )) swap ( u , v ); int bl = cmp ( calc ( u , t [ p ]. l ), calc ( v , t [ p ]. l )), br = cmp ( calc ( u , t [ p ]. r ), calc ( v , t [ p ]. r )); if ( bl == 1 || ( bl == 0 && u < v )) update ( p * 2 , u ); if ( br == 1 || ( br == 0 && u < v )) update ( p * 2 + 1 , u ); } void modify ( int p , int l , int r , int k ) { if ( l <= t [ p ]. l && r >= t [ p ]. r ) return update ( p , k ); if ( l <= t [ p * 2 ]. r ) modify ( p * 2 , l , r , k ); if ( r > t [ p * 2 ]. r ) modify ( p * 2 + 1 , l , r , k ); } pdi maxx ( pdi p1 , pdi p2 ) { if ( cmp ( p1 . fi , p2 . fi ) == 1 ) return p1 ; if ( cmp ( p1 . fi , p2 . fi ) == -1 ) return p2 ; return p1 . se < p2 . se ? p1 : p2 ; } pdi ask ( int p , int k ) { if ( t [ p ]. l == t [ p ]. r ) return mp ( calc ( t [ p ]. best , k ), t [ p ]. best ); pdi res = mp ( calc ( t [ p ]. best , k ), t [ p ]. best ); if ( k <= t [ p * 2 ]. r ) return maxx ( res , ask ( p * 2 , k )); return maxx ( res , ask ( p * 2 + 1 , k )); } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 namespace Segment { int cnt , tot , root ; pii b [ 200010 ]; struct { int ls , rs , i ;} t [ 200010 ]; #define ls(x) t[x].ls #define rs(x) t[x].rs inline int get ( int i , int x ){ return x * b [ i ]. fi + b [ i ]. se ;} void modify ( int & p , int L , int R , int i ) { if ( ! p ) return t [ p =++ tot ] = { 0 , 0 , i }, void (); int mid = ( L + R ) >> 1 ; if ( get ( i , mid ) > get ( t [ p ]. i , mid )) swap ( i , t [ p ]. i ); if ( get ( i , L ) > get ( t [ p ]. i , L )) modify ( ls ( p ), L , mid , i ); if ( get ( i , R ) > get ( t [ p ]. i , R )) modify ( rs ( p ), mid + 1 , R , i ); } int ask ( int p , int L , int R , int x ) { if ( ! p ) return - INF ; int mid = ( L + R ) >> 1 , v = get ( t [ p ]. i , x ); if ( x <= mid ) return max ( v , ask ( ls ( p ), L , mid , x )); return max ( v , ask ( rs ( p ), mid + 1 , R , x )); } void clr (){ root = cnt = tot = 0 ;} } using namespace Segment ;","title":"\u674e\u8d85\u6811"},{"location":"DS/Segment/","text":"Without Tag 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 template < class Info > struct Segment { #define ls(p) (t[p].l+t[p].r) #define rs(p) (ls(p)^1) private : vector < Info > tmp ; struct { int l , r ; Info v ;} t [ N << 1 ]; void build ( int p , int l , int r ) { t [ p ]. l = l , t [ p ]. r = r ; if ( l == r ) return t [ p ]. v = tmp [ l -1 ], void (); int mid = ( l + r ) >> 1 ; build ( ls ( p ), l , mid ), build ( rs ( p ), mid + 1 , r ); t [ p ]. v = t [ ls ( p )]. v + t [ rs ( p )]. v ; } public : void change ( int p , int x , Info v ) { if ( t [ p ]. l == t [ p ]. r ) return t [ p ]. v = v , void (); change ( ls ( p ) ^ ( x > t [ ls ( p )]. r ), x , v ); t [ p ]. v = t [ ls ( p )]. v + t [ rs ( p )]. v ; } Info ask ( int p , int l , int r ) { if ( l <= t [ p ]. l && r >= t [ p ]. r ) return t [ p ]. v ; if ( r <= t [ ls ( p )]. r ) return ask ( ls ( p ), l , r ); if ( l > t [ ls ( p )]. r ) return ask ( rs ( p ), l , r ); return ask ( ls ( p ), l , r ) + ask ( rs ( p ), l , r ); } template < class Compare > pair < int , Info > findnex ( int p , int x , Info y , Compare cmp ) { if ( x > t [ p ]. r ||! cmp ( y , t [ p ]. v )) return mp ( 0 ,( Info ){}); if ( t [ p ]. l == t [ p ]. r ) return mp ( t [ p ]. l , t [ p ]. v ); pair < int , Info > v = findnex ( ls ( p ), x , y , cmp ); if ( v . fi ) return v ; return findnex ( rs ( p ), x , y , cmp ); } template < class Compare > pair < int , Info > findpre ( int p , int x , Info y , Compare cmp ) { if ( x < t [ p ]. l ||! cmp ( y , t [ p ]. v )) return mp ( 0 ,( Info ){}); if ( t [ p ]. l == t [ p ]. r ) return mp ( t [ p ]. l , t [ p ]. v ); pair < int , Info > v = findpre ( rs ( p ), x , y , cmp ); if ( v . fi ) return v ; return findpre ( ls ( p ), x , y , cmp ); } void print ( int p = 1 ) { if ( t [ p ]. l == t [ p ]. r ) return t [ p ]. v . print (); print ( ls ( p )), print ( rs ( p )); } template < class Compare > pair < int , Info > findnex ( int x , Info y , Compare cmp ) { return findnex ( 1 , x , y , cmp );} template < class Compare > pair < int , Info > findpre ( int x , Info y , Compare cmp ) { return findpre ( 1 , x , y , cmp );} void change ( int x , Info v ){ change ( 1 , x , v );} Info ask ( int l , int r ){ return ask ( 1 , l , r );} void init ( vector < Info > ve ){ tmp = ve , build ( 1 , 1 , ve . size ());} #undef ls #undef rs }; struct Info { //... Info (){} Info operator + ( const Info nd ) const { //... } void print () { //... } }; With Tag 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 template < class Info , class Tag > struct Segment { #define ls(p) (t[p].l+t[p].r) #define rs(p) (ls(p)^1) private : vector < Info > tmp ; struct { int l , r ; Info v ; Tag tg ;} t [ N << 1 ]; inline void down ( int p , Tag tg ){ t [ p ]. v = t [ p ]. v * tg , t [ p ]. tg = t [ p ]. tg * tg ;} inline void spread ( int p ){ down ( ls ( p ), t [ p ]. tg ), down ( rs ( p ), t [ p ]. tg ), t [ p ]. tg = Tag ();} void build ( int p , int l , int r ) { t [ p ]. l = l , t [ p ]. r = r ; if ( l == r ) return t [ p ]. v = tmp [ l -1 ], void (); int mid = l + (( r - l ) >> 1 ); build ( ls ( p ), l , mid ), build ( rs ( p ), mid + 1 , r ); t [ p ]. v = t [ ls ( p )]. v + t [ rs ( p )]. v ; } void change ( int p , int x , Info v ) { if ( t [ p ]. l == t [ p ]. r ) return t [ p ]. v = v , void (); spread ( p ); change ( ls ( p ) ^ ( x > t [ ls ( p )]. r ), x , v ); t [ p ]. v = t [ ls ( p )]. v + t [ rs ( p )]. v ; } Info ask ( int p , int l , int r ) { if ( l <= t [ p ]. l && r >= t [ p ]. r ) return t [ p ]. v ; spread ( p ); if ( r <= t [ ls ( p )]. r ) return ask ( ls ( p ), l , r ); if ( l > t [ ls ( p )]. r ) return ask ( rs ( p ), l , r ); return ask ( ls ( p ), l , r ) + ask ( rs ( p ), l , r ); } void modify ( int p , int l , int r , Tag tg ) { if ( l <= t [ p ]. l && r >= t [ p ]. r ) return down ( p , tg ); spread ( p ); if ( l <= t [ ls ( p )]. r ) modify ( ls ( p ), l , r , tg ); if ( r > t [ ls ( p )]. r ) modify ( rs ( p ), l , r , tg ); t [ p ]. v = t [ ls ( p )]. v + t [ rs ( p )]. v ; } template < class Compare > pair < int , Info > findnex ( int p , int x , Info y , Compare cmp ) { if ( x > t [ p ]. r ||! cmp ( y , t [ p ]. v )) return mp ( 0 ,( Info ){}); if ( t [ p ]. l == t [ p ]. r ) return mp ( t [ p ]. l , t [ p ]. v ); spread ( p ); pair < int , Info > v = findnex ( ls ( p ), x , y , cmp ); if ( v . fi ) return v ; return findnex ( rs ( p ), x , y , cmp ); } template < class Compare > pair < int , Info > findpre ( int p , int x , Info y , Compare cmp ) { if ( x < t [ p ]. l ||! cmp ( y , t [ p ]. v )) return mp ( 0 ,( Info ){}); if ( t [ p ]. l == t [ p ]. r ) return mp ( t [ p ]. l , t [ p ]. v ); spread ( p ); pair < int , Info > v = findpre ( rs ( p ), x , y , cmp ); if ( v . fi ) return v ; return findpre ( ls ( p ), x , y , cmp ); } public : void print ( int p = 1 ) { if ( t [ p ]. l == t [ p ]. r ) return t [ p ]. v . print (); spread ( p ), print ( ls ( p )), print ( rs ( p )); } void printall ( int p = 1 ) { write ( '[' , t [ p ]. l , ',' , t [ p ]. r , ']' , ':' ); t [ p ]. v . print (); spread ( p ), print ( ls ( p )), print ( rs ( p )); } void modify ( int l , int r , Tag tg ){ modify ( 1 , l , r , tg );} template < class Compare > pair < int , Info > findnex ( int x , Info y , Compare cmp ) { return findnex ( 1 , x , y , cmp );} template < class Compare > pair < int , Info > findpre ( int x , Info y , Compare cmp ) { return findpre ( 1 , x , y , cmp );} void change ( int x , Info v ){ change ( 1 , x , v );} Info ask ( int l , int r ){ return ask ( 1 , l , r );} void init ( vector < Info > ve ){ tmp = ve , build ( 1 , 1 , ve . size ());} #undef ls #undef rs }; struct Tag { //... Tag (){} Tag operator * ( const Tag nd ) const { Tag v ; //... return v ; } }; struct Info { //... Info (){} Info operator + ( const Info nd ) const { Info v ; //... return v ; } Info operator * ( const Tag nd ) const { Info v ; //... return v ; } void print () { //... } };","title":"\u7ebf\u6bb5\u6811"},{"location":"DS/Segment/#without-tag","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 template < class Info > struct Segment { #define ls(p) (t[p].l+t[p].r) #define rs(p) (ls(p)^1) private : vector < Info > tmp ; struct { int l , r ; Info v ;} t [ N << 1 ]; void build ( int p , int l , int r ) { t [ p ]. l = l , t [ p ]. r = r ; if ( l == r ) return t [ p ]. v = tmp [ l -1 ], void (); int mid = ( l + r ) >> 1 ; build ( ls ( p ), l , mid ), build ( rs ( p ), mid + 1 , r ); t [ p ]. v = t [ ls ( p )]. v + t [ rs ( p )]. v ; } public : void change ( int p , int x , Info v ) { if ( t [ p ]. l == t [ p ]. r ) return t [ p ]. v = v , void (); change ( ls ( p ) ^ ( x > t [ ls ( p )]. r ), x , v ); t [ p ]. v = t [ ls ( p )]. v + t [ rs ( p )]. v ; } Info ask ( int p , int l , int r ) { if ( l <= t [ p ]. l && r >= t [ p ]. r ) return t [ p ]. v ; if ( r <= t [ ls ( p )]. r ) return ask ( ls ( p ), l , r ); if ( l > t [ ls ( p )]. r ) return ask ( rs ( p ), l , r ); return ask ( ls ( p ), l , r ) + ask ( rs ( p ), l , r ); } template < class Compare > pair < int , Info > findnex ( int p , int x , Info y , Compare cmp ) { if ( x > t [ p ]. r ||! cmp ( y , t [ p ]. v )) return mp ( 0 ,( Info ){}); if ( t [ p ]. l == t [ p ]. r ) return mp ( t [ p ]. l , t [ p ]. v ); pair < int , Info > v = findnex ( ls ( p ), x , y , cmp ); if ( v . fi ) return v ; return findnex ( rs ( p ), x , y , cmp ); } template < class Compare > pair < int , Info > findpre ( int p , int x , Info y , Compare cmp ) { if ( x < t [ p ]. l ||! cmp ( y , t [ p ]. v )) return mp ( 0 ,( Info ){}); if ( t [ p ]. l == t [ p ]. r ) return mp ( t [ p ]. l , t [ p ]. v ); pair < int , Info > v = findpre ( rs ( p ), x , y , cmp ); if ( v . fi ) return v ; return findpre ( ls ( p ), x , y , cmp ); } void print ( int p = 1 ) { if ( t [ p ]. l == t [ p ]. r ) return t [ p ]. v . print (); print ( ls ( p )), print ( rs ( p )); } template < class Compare > pair < int , Info > findnex ( int x , Info y , Compare cmp ) { return findnex ( 1 , x , y , cmp );} template < class Compare > pair < int , Info > findpre ( int x , Info y , Compare cmp ) { return findpre ( 1 , x , y , cmp );} void change ( int x , Info v ){ change ( 1 , x , v );} Info ask ( int l , int r ){ return ask ( 1 , l , r );} void init ( vector < Info > ve ){ tmp = ve , build ( 1 , 1 , ve . size ());} #undef ls #undef rs }; struct Info { //... Info (){} Info operator + ( const Info nd ) const { //... } void print () { //... } };","title":"Without Tag"},{"location":"DS/Segment/#with-tag","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 template < class Info , class Tag > struct Segment { #define ls(p) (t[p].l+t[p].r) #define rs(p) (ls(p)^1) private : vector < Info > tmp ; struct { int l , r ; Info v ; Tag tg ;} t [ N << 1 ]; inline void down ( int p , Tag tg ){ t [ p ]. v = t [ p ]. v * tg , t [ p ]. tg = t [ p ]. tg * tg ;} inline void spread ( int p ){ down ( ls ( p ), t [ p ]. tg ), down ( rs ( p ), t [ p ]. tg ), t [ p ]. tg = Tag ();} void build ( int p , int l , int r ) { t [ p ]. l = l , t [ p ]. r = r ; if ( l == r ) return t [ p ]. v = tmp [ l -1 ], void (); int mid = l + (( r - l ) >> 1 ); build ( ls ( p ), l , mid ), build ( rs ( p ), mid + 1 , r ); t [ p ]. v = t [ ls ( p )]. v + t [ rs ( p )]. v ; } void change ( int p , int x , Info v ) { if ( t [ p ]. l == t [ p ]. r ) return t [ p ]. v = v , void (); spread ( p ); change ( ls ( p ) ^ ( x > t [ ls ( p )]. r ), x , v ); t [ p ]. v = t [ ls ( p )]. v + t [ rs ( p )]. v ; } Info ask ( int p , int l , int r ) { if ( l <= t [ p ]. l && r >= t [ p ]. r ) return t [ p ]. v ; spread ( p ); if ( r <= t [ ls ( p )]. r ) return ask ( ls ( p ), l , r ); if ( l > t [ ls ( p )]. r ) return ask ( rs ( p ), l , r ); return ask ( ls ( p ), l , r ) + ask ( rs ( p ), l , r ); } void modify ( int p , int l , int r , Tag tg ) { if ( l <= t [ p ]. l && r >= t [ p ]. r ) return down ( p , tg ); spread ( p ); if ( l <= t [ ls ( p )]. r ) modify ( ls ( p ), l , r , tg ); if ( r > t [ ls ( p )]. r ) modify ( rs ( p ), l , r , tg ); t [ p ]. v = t [ ls ( p )]. v + t [ rs ( p )]. v ; } template < class Compare > pair < int , Info > findnex ( int p , int x , Info y , Compare cmp ) { if ( x > t [ p ]. r ||! cmp ( y , t [ p ]. v )) return mp ( 0 ,( Info ){}); if ( t [ p ]. l == t [ p ]. r ) return mp ( t [ p ]. l , t [ p ]. v ); spread ( p ); pair < int , Info > v = findnex ( ls ( p ), x , y , cmp ); if ( v . fi ) return v ; return findnex ( rs ( p ), x , y , cmp ); } template < class Compare > pair < int , Info > findpre ( int p , int x , Info y , Compare cmp ) { if ( x < t [ p ]. l ||! cmp ( y , t [ p ]. v )) return mp ( 0 ,( Info ){}); if ( t [ p ]. l == t [ p ]. r ) return mp ( t [ p ]. l , t [ p ]. v ); spread ( p ); pair < int , Info > v = findpre ( rs ( p ), x , y , cmp ); if ( v . fi ) return v ; return findpre ( ls ( p ), x , y , cmp ); } public : void print ( int p = 1 ) { if ( t [ p ]. l == t [ p ]. r ) return t [ p ]. v . print (); spread ( p ), print ( ls ( p )), print ( rs ( p )); } void printall ( int p = 1 ) { write ( '[' , t [ p ]. l , ',' , t [ p ]. r , ']' , ':' ); t [ p ]. v . print (); spread ( p ), print ( ls ( p )), print ( rs ( p )); } void modify ( int l , int r , Tag tg ){ modify ( 1 , l , r , tg );} template < class Compare > pair < int , Info > findnex ( int x , Info y , Compare cmp ) { return findnex ( 1 , x , y , cmp );} template < class Compare > pair < int , Info > findpre ( int x , Info y , Compare cmp ) { return findpre ( 1 , x , y , cmp );} void change ( int x , Info v ){ change ( 1 , x , v );} Info ask ( int l , int r ){ return ask ( 1 , l , r );} void init ( vector < Info > ve ){ tmp = ve , build ( 1 , 1 , ve . size ());} #undef ls #undef rs }; struct Tag { //... Tag (){} Tag operator * ( const Tag nd ) const { Tag v ; //... return v ; } }; struct Info { //... Info (){} Info operator + ( const Info nd ) const { Info v ; //... return v ; } Info operator * ( const Tag nd ) const { Info v ; //... return v ; } void print () { //... } };","title":"With Tag"},{"location":"DS/Splay/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 struct { int fa , ch [ 2 ], val , siz , sum ; bool tag ;} spl [ 1000001 ]; #define ls(x) (spl[x].ch[0]) #define rs(x) (spl[x].ch[1]) #define fa(x) (spl[x].fa) #define ident(x,f) (rs(f)==x) #define connect(x,f,s) (spl[fa(x)=f].ch[s]=x) #define update(x) (spl[x].siz=spl[ls(x)].siz+spl[rs(x)].siz+1,spl[x].sum=spl[ls(x)].sum^spl[rs(x)].sum^spl[x].val) #define down(x) (swap(ls(x),rs(x)),spl[x].tag^=1) inline void spread ( int k ) { if ( spl [ k ]. tag ) down ( ls ( k )), down ( rs ( k )); spl [ k ]. tag = 0 ; } inline void rotate ( int x ) { int f = fa ( x ), ff = fa ( f ), s = ident ( x , f ); connect ( spl [ x ]. ch [ s ^ 1 ], f , s ), connecf ( x , ff , ident ( f , ff )); connect ( f , x , s ^ 1 ), update ( f ), update ( x ); } inline void splaying ( int x ) { while ( fa ( x )) { int f = fa ( x ), ff = fa ( f ); if ( fa ( f ))( ident ( x , f ) ^ ident ( f , ff )) ? rotate ( x ) : rotate ( f ); rotate ( x ); } }","title":"Splay"},{"location":"DS/delheap/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template < class Node > struct Delheap { priority_queue < Node > p , q ; inline void push ( int x ){ q . e ( x );} inline void erase ( int x ){ p . e ( x );} inline void upd () { while ( p . size () && q . size () &&! ( p . top () < q . top ()) &&! ( q . top () < p . top ())) q . pop (), p . pop (); } inline void pop (){ return upd (), q . pop ();} inline int size (){ return p . size () - q . size ();} inline int empty (){ return p . size () == q . size ();} inline int top (){ return upd (), q . top ();} };","title":"\u53ef\u5220\u5806"},{"location":"DS/delset/","text":"1 2 3 4 5 6 7 8 9 10 const int N = 100000 ; struct Delset { int t [ N + 10 ]; int top , st [ N + 10 ]; void push ( int x ){ st [ ++ top ] = x ;} void erase ( int x ){ ++ t [ x ];} void upd (){ while ( top && t [ st [ top ]]) -- t [ st [ top -- ]];} int get (){ return upd (), st [ top ];} };","title":"\u53ef\u5220\u96c6\u5408"},{"location":"DS/exFHQ/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 struct Node { int l , r , siz , rd ; bool tag ; long long val , sum ;} fhq [ 20000001 ]; int cnt , n , root [ 300001 ]; long long lastans = 0 ; inline void update ( int x ) { fhq [ x ]. siz = fhq [ fhq [ x ]. l ]. siz + fhq [ fhq [ x ]. r ]. siz + 1 ; fhq [ x ]. sum = fhq [ fhq [ x ]. l ]. sum + fhq [ fhq [ x ]. r ]. sum + fhq [ x ]. val ; } inline int newnode ( long long val ){ fhq [ ++ cnt ]. val = val , fhq [ cnt ]. siz = 1 , fhq [ cnt ]. sum = val , fhq [ cnt ]. rd = rand () % 114514191 ; return cnt ;} inline int copy ( int x ){ fhq [ ++ cnt ] = fhq [ x ]; return cnt ;} inline void spread ( int x ) { if ( fhq [ x ]. tag ) { if ( fhq [ x ]. l ) fhq [ x ]. l = copy ( fhq [ x ]. l ); if ( fhq [ x ]. r ) fhq [ x ]. r = copy ( fhq [ x ]. r ); swap ( fhq [ x ]. l , fhq [ x ]. r ); if ( fhq [ x ]. l ) fhq [ fhq [ x ]. l ]. tag ^= 1 ; if ( fhq [ x ]. r ) fhq [ fhq [ x ]. r ]. tag ^= 1 ; fhq [ x ]. tag = 0 ; } } void split ( int now , int siz , int & x , int & y ) { if ( ! now ){ x = y = 0 ; return ;} spread ( now ); if ( fhq [ fhq [ now ]. l ]. siz + 1 <= siz ) x = copy ( now ), split ( fhq [ x ]. r , siz - fhq [ fhq [ x ]. l ]. siz -1 , fhq [ x ]. r , y ), update ( x ); else y = copy ( now ), split ( fhq [ y ]. l , siz , x , fhq [ y ]. l ), update ( y ); } int merge ( int x , int y ) { if ( ! x ||! y ) return x + y ; spread ( x ), spread ( y ); if ( fhq [ x ]. rd < fhq [ y ]. rd ){ fhq [ x ]. r = merge ( fhq [ x ]. r , y ), update ( x ); return x ;} fhq [ y ]. l = merge ( x , fhq [ y ]. l ), update ( y ); return y ; }","title":"\u53ef\u6301\u4e45\u5316\u5e73\u8861\u6811"},{"location":"Graph/HLD/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 struct _HLP { int tot , * siz , * dep , * son ; int * top , * dfn , * id , * fa ; void init ( vi * T , int n , int rt = 1 ) { siz = new int [ n + 1 ], dep = new int [ n + 1 ], son = new int [ n + 1 ], top = new int [ n + 1 ]; dfn = new int [ n + 1 ], id = new int [ n + 1 ], fa = new int [ n + 1 ]; tot = dep [ 0 ] = id [ 0 ] = dfn [ 0 ] = fa [ 0 ] = siz [ 0 ] = top [ 0 ] = 0 ; auto dfs0 = [ & ]( auto dfs0 , int x , int Fa = 0 ) -> void { fa [ x ] = Fa , siz [ x ] = 1 ; dep [ x ] = dep [ Fa ] + 1 ; for ( auto to : T [ x ]) if ( to != Fa ) { dfs0 ( dfs0 , to , x ), siz [ x ] += siz [ to ]; if ( siz [ to ] > siz [ son [ x ]]) son [ x ] = to ; } }; auto dfs1 = [ & ]( auto dfs1 , int x , int Top = 1 ) -> void { top [ x ] = Top ; id [ dfn [ x ] =++ tot ] = x ; if ( son [ x ]) dfs1 ( dfs1 , son [ x ], Top ); for ( auto to : T [ x ]) if ( to != fa [ x ] && to != son [ x ]) dfs1 ( dfs1 , to , to ); }; dfs0 ( dfs0 , rt ), dfs1 ( dfs1 , rt ); } };","title":"\u6811\u94fe\u5256\u5206"},{"location":"Graph/KM/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 int t [ 501 ][ 501 ]; int n , m , match [ 501 ], pre [ 501 ]; ll ex [ 501 ], ey [ 501 ], vy [ 501 ], slack [ 501 ]; void bfs ( int k ) { ll x , y = 0 , yy = 0 , delta ; memset ( pre , 0 , sizeof ( pre )), memset ( slack , 127 , sizeof ( slack )), match [ y ] = k ; while ( 1 ) { x = match [ y ]; delta = INF , vy [ y ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( vy [ i ]) continue ; if ( slack [ i ] > ex [ x ] + ey [ i ] - t [ x ][ i ]) slack [ i ] = ex [ x ] + ey [ i ] - t [ x ][ i ], pre [ i ] = y ; if ( slack [ i ] < delta ) delta = slack [ i ], yy = i ; } for ( int i = 0 ; i <= n ; ++ i ) { if ( vy [ i ]) ex [ match [ i ]] -= delta , ey [ i ] += delta ; else slack [ i ] -= delta ; } y = yy ; if ( match [ y ] == -1 ) break ; } while ( y ){ match [ y ] = match [ pre [ y ]], y = pre [ y ];} } ll KM () { memset ( match , -1 , sizeof ( match )), memset ( ex , 0 , sizeof ( ex )), memset ( ey , 0 , sizeof ( ey )); for ( int i = 1 ; i <= n ; ++ i ) memset ( vy , 0 , sizeof ( vy )), bfs ( i ); ll res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) if ( match [ i ] != -1 ) res += t [ match [ i ]][ i ]; return res ; }","title":"KM \u7b97\u6cd5"},{"location":"Graph/LCA/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 struct _LCA { int * dfn , * F [ 19 ]; inline int get ( int x , int y ){ return dfn [ x ] < dfn [ y ] ? x : y ;} inline int lca ( int x , int y ) { if ( x == y ) return x ; if (( x = dfn [ x ]) > ( y = dfn [ y ])) swap ( x , y ); int k = __lg ( y - x ++ ); return get ( F [ k ][ x ], F [ k ][ y - ( 1 << k ) + 1 ]); } void init ( vi * T , int n , int rt = 1 ) { dfn = new int [ n + 1 ]; for ( int i = 0 ; i < 19 ; ++ i ) F [ i ] = new int [ n + 1 ]; tot = dfn [ 0 ] = 0 ; auto dfs = [ & ]( auto dfs , int x , int fa ) -> void { F [ 0 ][ dfn [ x ] =++ tot ] = fa ; for ( auto to : T [ x ]) if ( to != fa ) dfs ( dfs , to , x ); }; dfs ( dfs , rt , 0 ); for ( int i = 1 ; i < 19 ; ++ i ) { for ( int j = 1 ; j + ( 1 << i ) -1 <= n ; ++ j ) F [ i ][ j ] = get ( F [ i -1 ][ j ], F [ i -1 ][ j + ( 1 << ( i -1 ))]); } } };","title":"dfs \u5e8f LCA"},{"location":"Graph/connection/","text":"\u8fb9\u53cc\u8054\u901a\u5206\u91cf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const int N = 100000 , M = 200000 ; int n , m , cnt = 1 , num , col , low [ N + 10 ], dfn [ N + 10 ], head [ N + 10 ], to [ M + 10 ], nex [ M + 10 ]; inline void add ( int x , int y ){ to [ ++ cnt ] = y , nex [ cnt ] = head [ x ], head [ x ] = cnt ;} stack < int > st ; vi ve [ N + 10 ]; void tarjan ( int x , int fromi ) { dfn [ x ] = low [ x ] =++ num , st . e ( x ); for ( int i = head [ x ]; i ; i = nex [ i ]) { if ( i == ( fromi ^ 1 )) continue ; if ( ! dfn [ to [ i ]]) tarjan ( to [ i ], i ), low [ x ] = min ( low [ x ], low [ to [ i ]]); else low [ x ] = min ( low [ x ], dfn [ to [ i ]]); } if ( low [ x ] == dfn [ x ]) { int y ; ++ col ; do ve [ col ]. eb ( y = st . top ()), st . pop (); while ( y != x ); } } \u5f3a\u8054\u901a\u5206\u91cf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const int N = 100000 ; int tot , dfn [ N + 10 ], low [ N + 10 ]; int num , c [ N + 10 ]; int ins [ N + 10 ]; stack < int > st ; vi G [ N + 10 ]; void tarjan ( int x ) { st . e ( x ), ins [ x ] = 1 , dfn [ x ] = low [ x ] =++ tot ; for ( auto to : G [ x ]) { if ( ! dfn [ to ]) tarjan ( to ), low [ x ] = min ( low [ x ], low [ to ]); else if ( ins [ to ]) low [ x ] = min ( low [ x ], dfn [ to ]); } if ( dfn [ x ] == low [ x ]) { int y ; ++ num ; do c [ y = st . top ()] = num , ins [ y ] = 0 , st . pop (); while ( y != x ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 const int N = 100000 , M = 200010 ; int cnt , head [ M + 10 ], to [ M + 10 ], nex [ M + 10 ]; int tot , dfn [ N + 10 ], low [ N + 10 ]; int num , c [ N + 10 ]; int ins [ N + 10 ]; inline void add ( int x , int y ){ to [ ++ cnt ] = y , nex [ cnt ] = head [ x ], head [ x ] = cnt ;} stack < int > st ; void tarjan ( int x ) { st . e ( x ), ins [ x ] = 1 , dfn [ x ] = low [ x ] =++ tot ; for ( int i = head [ x ]; i ; i = nex [ i ]) { if ( ! dfn [ to [ i ]]) tarjan ( to [ i ]), low [ x ] = min ( low [ x ], low [ to [ i ]]); else if ( ins [ to [ i ]]) low [ x ] = min ( low [ x ], dfn [ to [ i ]]); } if ( dfn [ x ] == low [ x ]) { int y ; ++ num ; do c [ y = st . top ()] = num , ins [ y ] = 0 , st . pop (); while ( y != x ); } } \u5e7f\u4e49\u5706\u65b9\u6811 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const int N = 100010 ; int tot , low [ N + 10 ], dfn [ N + 10 ]; int num ; vi G [ N + 10 ], T [ N * 2 + 10 ]; stack < int > st ; void tarjan ( int x ) { low [ x ] = dfn [ x ] =++ tot , st . e ( x ); int y ; for ( auto to : G [ x ]) { if ( ! dfn [ to ]) { tarjan ( to ), low [ x ] = min ( low [ x ], low [ to ]); if ( low [ to ] >= dfn [ x ]) { T [ ++ num ]. eb ( x ), T [ x ]. eb ( num ); do T [ num ]. eb ( y = st . top ()), T [ st . top ()]. eb ( num ), st . pop (); while ( y != to ); } } else low [ x ] = min ( low [ x ], dfn [ to ]); } }","title":"\u8fde\u901a\u6027"},{"location":"Graph/connection/#\u8fb9\u53cc\u8054\u901a\u5206\u91cf","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const int N = 100000 , M = 200000 ; int n , m , cnt = 1 , num , col , low [ N + 10 ], dfn [ N + 10 ], head [ N + 10 ], to [ M + 10 ], nex [ M + 10 ]; inline void add ( int x , int y ){ to [ ++ cnt ] = y , nex [ cnt ] = head [ x ], head [ x ] = cnt ;} stack < int > st ; vi ve [ N + 10 ]; void tarjan ( int x , int fromi ) { dfn [ x ] = low [ x ] =++ num , st . e ( x ); for ( int i = head [ x ]; i ; i = nex [ i ]) { if ( i == ( fromi ^ 1 )) continue ; if ( ! dfn [ to [ i ]]) tarjan ( to [ i ], i ), low [ x ] = min ( low [ x ], low [ to [ i ]]); else low [ x ] = min ( low [ x ], dfn [ to [ i ]]); } if ( low [ x ] == dfn [ x ]) { int y ; ++ col ; do ve [ col ]. eb ( y = st . top ()), st . pop (); while ( y != x ); } }","title":"\u8fb9\u53cc\u8054\u901a\u5206\u91cf"},{"location":"Graph/connection/#\u5f3a\u8054\u901a\u5206\u91cf","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const int N = 100000 ; int tot , dfn [ N + 10 ], low [ N + 10 ]; int num , c [ N + 10 ]; int ins [ N + 10 ]; stack < int > st ; vi G [ N + 10 ]; void tarjan ( int x ) { st . e ( x ), ins [ x ] = 1 , dfn [ x ] = low [ x ] =++ tot ; for ( auto to : G [ x ]) { if ( ! dfn [ to ]) tarjan ( to ), low [ x ] = min ( low [ x ], low [ to ]); else if ( ins [ to ]) low [ x ] = min ( low [ x ], dfn [ to ]); } if ( dfn [ x ] == low [ x ]) { int y ; ++ num ; do c [ y = st . top ()] = num , ins [ y ] = 0 , st . pop (); while ( y != x ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 const int N = 100000 , M = 200010 ; int cnt , head [ M + 10 ], to [ M + 10 ], nex [ M + 10 ]; int tot , dfn [ N + 10 ], low [ N + 10 ]; int num , c [ N + 10 ]; int ins [ N + 10 ]; inline void add ( int x , int y ){ to [ ++ cnt ] = y , nex [ cnt ] = head [ x ], head [ x ] = cnt ;} stack < int > st ; void tarjan ( int x ) { st . e ( x ), ins [ x ] = 1 , dfn [ x ] = low [ x ] =++ tot ; for ( int i = head [ x ]; i ; i = nex [ i ]) { if ( ! dfn [ to [ i ]]) tarjan ( to [ i ]), low [ x ] = min ( low [ x ], low [ to [ i ]]); else if ( ins [ to [ i ]]) low [ x ] = min ( low [ x ], dfn [ to [ i ]]); } if ( dfn [ x ] == low [ x ]) { int y ; ++ num ; do c [ y = st . top ()] = num , ins [ y ] = 0 , st . pop (); while ( y != x ); } }","title":"\u5f3a\u8054\u901a\u5206\u91cf"},{"location":"Graph/connection/#\u5e7f\u4e49\u5706\u65b9\u6811","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const int N = 100010 ; int tot , low [ N + 10 ], dfn [ N + 10 ]; int num ; vi G [ N + 10 ], T [ N * 2 + 10 ]; stack < int > st ; void tarjan ( int x ) { low [ x ] = dfn [ x ] =++ tot , st . e ( x ); int y ; for ( auto to : G [ x ]) { if ( ! dfn [ to ]) { tarjan ( to ), low [ x ] = min ( low [ x ], low [ to ]); if ( low [ to ] >= dfn [ x ]) { T [ ++ num ]. eb ( x ), T [ x ]. eb ( num ); do T [ num ]. eb ( y = st . top ()), T [ st . top ()]. eb ( num ), st . pop (); while ( y != to ); } } else low [ x ] = min ( low [ x ], dfn [ to ]); } }","title":"\u5e7f\u4e49\u5706\u65b9\u6811"},{"location":"Graph/flow/","text":"\u6700\u5927\u6d41 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 int S , T , cnt = 1 , head [ 1210 ], to [ 100010 ], nex [ 100010 ], v [ 100010 ], d [ 1210 ], now [ 1210 ]; inline void Add ( int x , int y , int z ){ to [ ++ cnt ] = y , nex [ cnt ] = head [ x ], head [ x ] = cnt , v [ cnt ] = z ;} inline void add ( int x , int y , int z ){ Add ( x , y , z ), Add ( y , x , 0 );} queue < int > q ; int bfs () { while ( ! q . empty ()) q . pop (); q . e ( S ), memset ( d , 0 , sizeof ( d )), d [ S ] = 1 , now [ S ] = head [ S ]; while ( ! q . empty ()) { int k = q . front (); q . pop (); for ( int i = head [ k ]; i ; i = nex [ i ]) { if ( v [ i ] &&! d [ to [ i ]]) { d [ to [ i ]] = d [ k ] + 1 , now [ to [ i ]] = head [ to [ i ]], q . e ( to [ i ]); if ( to [ i ] == T ) return 1 ; } } } return 0 ; } int dinic ( int k , int flow ) { if ( k == T ) return flow ; int rest = flow , t ; for ( int i = now [ k ]; i && rest ; i = nex [ i ]) { now [ k ] = i ; if ( d [ to [ i ]] != d [ k ] + 1 ||! v [ i ]) continue ; t = dinic ( to [ i ], min ( v [ i ], rest )); if ( ! t ) d [ to [ i ]] = 0 ; rest -= t , v [ i ] -= t , v [ i ^ 1 ] += t ; } return flow - rest ; } \u8d39\u7528\u6d41 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 int cnt = 1 , S , T , sum , ans , incf [ 5010 ], pre [ 5010 ], d [ 5010 ], h [ 5010 ], head [ 5010 ], to [ 100010 ], nex [ 100010 ], v [ 100010 ], c [ 100010 ]; inline void Add ( int x , int y , int z , int t ){ to [ ++ cnt ] = y , v [ cnt ] = z , nex [ cnt ] = head [ x ], c [ cnt ] = t , head [ x ] = cnt ;} inline void add ( int x , int y , int z , int t ){ Add ( x , y , z , t ), Add ( y , x , 0 , - t );} priority_queue < pii > q ; bool vis [ 5010 ]; bool dij () { for ( int i = 1 ; i <= n ; ++ i ) if ( vis [ i ]) h [ i ] += d [ i ]; memset ( d , 127 , sizeof ( d )), memset ( incf , 0 , sizeof ( incf )), memset ( vis , 0 , sizeof ( vis )); incf [ S ] = inf , d [ S ] = 0 , q . e ( mp ( 0 , S )); while ( ! q . empty ()) { int now = q . top (). se ; q . pop (); if ( vis [ now ]) continue ; vis [ now ] = 1 ; for ( int i = head [ now ]; i ; i = nex [ i ]) { if ( v [ i ] && Mmin ( d [ to [ i ]], d [ now ] + c [ i ] + h [ now ] - h [ to [ i ]])) incf [ to [ i ]] = min ( v [ i ], incf [ now ]), pre [ to [ i ]] = i , q . e ( mp ( - d [ to [ i ]], to [ i ])); } } return incf [ T ]; } inline void update () { int now = T ; sum += incf [ T ], ans += incf [ T ] * ( d [ T ] - h [ S ] + h [ T ]); while ( now != S ) v [ pre [ now ]] -= incf [ T ], v [ pre [ now ] ^ 1 ] += incf [ T ], now = to [ pre [ now ] ^ 1 ]; }","title":"\u7f51\u7edc\u6d41"},{"location":"Graph/flow/#\u6700\u5927\u6d41","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 int S , T , cnt = 1 , head [ 1210 ], to [ 100010 ], nex [ 100010 ], v [ 100010 ], d [ 1210 ], now [ 1210 ]; inline void Add ( int x , int y , int z ){ to [ ++ cnt ] = y , nex [ cnt ] = head [ x ], head [ x ] = cnt , v [ cnt ] = z ;} inline void add ( int x , int y , int z ){ Add ( x , y , z ), Add ( y , x , 0 );} queue < int > q ; int bfs () { while ( ! q . empty ()) q . pop (); q . e ( S ), memset ( d , 0 , sizeof ( d )), d [ S ] = 1 , now [ S ] = head [ S ]; while ( ! q . empty ()) { int k = q . front (); q . pop (); for ( int i = head [ k ]; i ; i = nex [ i ]) { if ( v [ i ] &&! d [ to [ i ]]) { d [ to [ i ]] = d [ k ] + 1 , now [ to [ i ]] = head [ to [ i ]], q . e ( to [ i ]); if ( to [ i ] == T ) return 1 ; } } } return 0 ; } int dinic ( int k , int flow ) { if ( k == T ) return flow ; int rest = flow , t ; for ( int i = now [ k ]; i && rest ; i = nex [ i ]) { now [ k ] = i ; if ( d [ to [ i ]] != d [ k ] + 1 ||! v [ i ]) continue ; t = dinic ( to [ i ], min ( v [ i ], rest )); if ( ! t ) d [ to [ i ]] = 0 ; rest -= t , v [ i ] -= t , v [ i ^ 1 ] += t ; } return flow - rest ; }","title":"\u6700\u5927\u6d41"},{"location":"Graph/flow/#\u8d39\u7528\u6d41","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 int cnt = 1 , S , T , sum , ans , incf [ 5010 ], pre [ 5010 ], d [ 5010 ], h [ 5010 ], head [ 5010 ], to [ 100010 ], nex [ 100010 ], v [ 100010 ], c [ 100010 ]; inline void Add ( int x , int y , int z , int t ){ to [ ++ cnt ] = y , v [ cnt ] = z , nex [ cnt ] = head [ x ], c [ cnt ] = t , head [ x ] = cnt ;} inline void add ( int x , int y , int z , int t ){ Add ( x , y , z , t ), Add ( y , x , 0 , - t );} priority_queue < pii > q ; bool vis [ 5010 ]; bool dij () { for ( int i = 1 ; i <= n ; ++ i ) if ( vis [ i ]) h [ i ] += d [ i ]; memset ( d , 127 , sizeof ( d )), memset ( incf , 0 , sizeof ( incf )), memset ( vis , 0 , sizeof ( vis )); incf [ S ] = inf , d [ S ] = 0 , q . e ( mp ( 0 , S )); while ( ! q . empty ()) { int now = q . top (). se ; q . pop (); if ( vis [ now ]) continue ; vis [ now ] = 1 ; for ( int i = head [ now ]; i ; i = nex [ i ]) { if ( v [ i ] && Mmin ( d [ to [ i ]], d [ now ] + c [ i ] + h [ now ] - h [ to [ i ]])) incf [ to [ i ]] = min ( v [ i ], incf [ now ]), pre [ to [ i ]] = i , q . e ( mp ( - d [ to [ i ]], to [ i ])); } } return incf [ T ]; } inline void update () { int now = T ; sum += incf [ T ], ans += incf [ T ] * ( d [ T ] - h [ S ] + h [ T ]); while ( now != S ) v [ pre [ now ]] -= incf [ T ], v [ pre [ now ] ^ 1 ] += incf [ T ], now = to [ pre [ now ] ^ 1 ]; }","title":"\u8d39\u7528\u6d41"},{"location":"Graph/prufer/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int n , d [ 1000010 ], f [ 1000010 ], p [ 1000010 ]; inline void change () { for ( int i = 1 ; i < n ; ++ i ) ++ d [ f [ i ]]; for ( int i = 1 , j = 1 ; i <= n -2 ; ++ i , ++ j ) { while ( d [ j ]) ++ j ; p [ i ] = f [ j ]; while ( i <= n -2 &&!-- d [ p [ i ]] && p [ i ] < j ) p [ i + 1 ] = f [ p [ i ]], ++ i ; } } inline void recover () { for ( int i = 1 ; i <= n -2 ; ++ i ) ++ d [ p [ i ]]; p [ n -1 ] = n ; for ( int i = 1 , j = 1 ; i < n ; ++ i , ++ j ) { while ( d [ j ]) ++ j ; f [ j ] = p [ i ]; while ( i < n &&!-- d [ p [ i ]] && p [ i ] < j ) f [ p [ i ]] = p [ i + 1 ], ++ i ; } }","title":"prufer \u5e8f"},{"location":"Graph/starch/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int all , minn , root , siz [ 100010 ]; bool vis [ 100010 ]; vi T [ 100010 ]; void findrt ( int x , int fa = 0 ) { siz [ x ] = 1 ; int maxn = 0 ; for ( auto to : T [ x ]) if ( to != fa ) { findrt ( to , x ), siz [ x ] += siz [ to ]; Mmax ( maxn , siz [ to ]); } if ( Mmin ( minn , max ( maxn , all - siz [ x ]))) root = x ; } void starch ( int x ) { minn = inf , findrt ( x ), findrt ( x = root ), vis [ x ] = 1 ; //... for ( auto to : T [ x ]) if ( ! vis [ to ]) all = siz [ to ], starch ( to ); }","title":"\u70b9\u5206\u6cbb"},{"location":"Graph/treehash/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int T , n , siz [ 101 ], power [ 101 ], g [ 101 ], dep [ 101 ], head [ 101 ], to [ 101 ], nex [ 101 ], cnt , root1 , root2 ; pii f [ 101 ]; void dfs ( int k , int fa ) { siz [ k ] = 1 ; int maxn = 0 ; for ( int i = head [ k ]; i ; i = nex [ i ]) if ( to [ i ] != fa ) dfs ( to [ i ], k ), maxn = max ( maxn , siz [ to [ i ]]), siz [ k ] += siz [ to [ i ]]; if (( n - siz [ k ]) <= n / 2 && maxn <= n / 2 ) root1 ? root2 = k : root1 = k ; } void dfs2 ( int k , int fa ) { dep [ k ] = dep [ fa ] + 1 , g [ k ] = power [ 1 ] * dep [ k ], siz [ k ] = 1 ; pii a [ 51 ]; int tot = 0 ; for ( int i = head [ k ]; i ; i = nex [ i ]) if ( to [ i ] != fa ) dfs2 ( to [ i ], k ), siz [ k ] += siz [ to [ i ]], a [ ++ tot ] = mp ( g [ to [ i ]], to [ i ]); sort ( a + 1 , a + 1 + tot ); int now = 1 ; for ( int i = 1 ; i <= tot ; ++ i ) g [ k ] += g [ a [ i ]. se ] * power [ now ], now += siz [ a [ i ]. se ]; } inline void add ( int x , int y ){ to [ ++ cnt ] = y , nex [ cnt ] = head [ x ], head [ x ] = cnt ;} pii calc () { power [ 0 ] = 1 ; int x ; pii p ; for ( int i = 1 ; i <= 50 ; ++ i ) power [ i ] = power [ i -1 ] * 13331 ; root1 = root2 = 0 , dfs ( tmp , 0 ), dfs2 ( root1 , 0 ), p . fi = g [ root1 ]; root2 ? root1 = root2 : 0 , dfs2 ( root1 , 0 ), p . se = g [ root1 ]; if ( p . fi > p . se ) swap ( p . fi , p . se ); return p ; }","title":"\u6811\u54c8\u5e0c"},{"location":"Math/barrett/","text":"1 2 3 int P , iP ; inline void init ( int _P ){ P = _P , iP = ( __int128 ( 1 ) << 64 ) / P + 1 ;} inline int Cmod ( ll x ){ return x - ( __int128 ( x ) * iP >> 64 ) * P ;}","title":"Barrett"},{"location":"Math/fr%26inv/","text":"1 2 3 4 5 6 7 8 9 10 const int N = 1000000 ; int fr [ N + 10 ], inv [ N + 10 ]; inline int C ( int n , int m ){ return Cmul ( fr [ n ], inv [ m ], inv [ n - m ]);} inline void init ( int n = N ) { fr [ 0 ] = inv [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) fr [ i ] = Cmul ( fr [ i -1 ], i ); inv [ n ] = power ( fr [ n ], MOD -2 ); for ( int i = n -1 ; i > 0 ; -- i ) inv [ i ] = Cmul ( inv [ i + 1 ], i + 1 ); }","title":"\u7ec4\u5408\u6570\u9884\u5904\u7406"},{"location":"Math/Linear/determinant/","text":"\u666e\u901a\u9ad8\u6d88 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int n , p , f [ 610 ][ 610 ]; inline void del ( int x , int y , int z ){ for ( int i = 1 ; i <= n ; ++ i ) f [ x ][ i ] = ( f [ x ][ i ] -1ll * z * f [ y ][ i ] % p + p ) % p ;} inline void swp ( int x , int y ){ swap ( f [ x ], f [ y ]);} inline int solve () { int ans = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int pos = 0 ; for ( int j = i ; j <= n ; ++ j ) if ( f [ j ][ i ]){ pos = j ; break ;} if ( ! pos ) return 0 ; if ( pos != i ) ans = Cdel ( 0 , ans ); for ( int j = 1 ; j <= n ; ++ j ) swap ( f [ pos ][ j ], f [ i ][ j ]); for ( int j = i ; j <= n ; ++ j ) { int v = Cmul ( f [ j ][ i ], power ( f [ i ][ i ], MOD -2 )); for ( int k = i ; k <= n ; ++ k ) Mdel ( f [ j ][ k ], Cmul ( f [ i ][ k ], v )); } Mmul ( ans , f [ i ][ i ]); } return ans ; } \u8f97\u8f6c\u76f8\u9664\u6cd5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int n , p , f [ 610 ][ 610 ]; inline void del ( int x , int y , int z ){ for ( int i = 1 ; i <= n ; ++ i ) f [ x ][ i ] = ( f [ x ][ i ] -1ll * z * f [ y ][ i ] % p + p ) % p ;} inline void swp ( int x , int y ){ swap ( f [ x ], f [ y ]);} inline int solve () { int ans = 1 ; for ( int i = n ; i >= 1 ; -- i ) { for ( int j = 1 ; j < i ; ++ j ) { while ( f [ j ][ i ] && f [ i ][ i ]) { if ( f [ j ][ i ] > f [ i ][ i ]) del ( j , i , f [ j ][ i ] / f [ i ][ i ]); else del ( i , j , f [ i ][ i ] / f [ j ][ i ]); } if ( f [ j ][ i ]) ans = p - ans , swp ( i , j ); } ans = 1l l * ans * f [ i ][ i ] % p ; } return ans ; }","title":"\u884c\u5217\u5f0f\u6c42\u503c"},{"location":"Math/Linear/determinant/#\u666e\u901a\u9ad8\u6d88","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int n , p , f [ 610 ][ 610 ]; inline void del ( int x , int y , int z ){ for ( int i = 1 ; i <= n ; ++ i ) f [ x ][ i ] = ( f [ x ][ i ] -1ll * z * f [ y ][ i ] % p + p ) % p ;} inline void swp ( int x , int y ){ swap ( f [ x ], f [ y ]);} inline int solve () { int ans = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int pos = 0 ; for ( int j = i ; j <= n ; ++ j ) if ( f [ j ][ i ]){ pos = j ; break ;} if ( ! pos ) return 0 ; if ( pos != i ) ans = Cdel ( 0 , ans ); for ( int j = 1 ; j <= n ; ++ j ) swap ( f [ pos ][ j ], f [ i ][ j ]); for ( int j = i ; j <= n ; ++ j ) { int v = Cmul ( f [ j ][ i ], power ( f [ i ][ i ], MOD -2 )); for ( int k = i ; k <= n ; ++ k ) Mdel ( f [ j ][ k ], Cmul ( f [ i ][ k ], v )); } Mmul ( ans , f [ i ][ i ]); } return ans ; }","title":"\u666e\u901a\u9ad8\u6d88"},{"location":"Math/Linear/determinant/#\u8f97\u8f6c\u76f8\u9664\u6cd5","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int n , p , f [ 610 ][ 610 ]; inline void del ( int x , int y , int z ){ for ( int i = 1 ; i <= n ; ++ i ) f [ x ][ i ] = ( f [ x ][ i ] -1ll * z * f [ y ][ i ] % p + p ) % p ;} inline void swp ( int x , int y ){ swap ( f [ x ], f [ y ]);} inline int solve () { int ans = 1 ; for ( int i = n ; i >= 1 ; -- i ) { for ( int j = 1 ; j < i ; ++ j ) { while ( f [ j ][ i ] && f [ i ][ i ]) { if ( f [ j ][ i ] > f [ i ][ i ]) del ( j , i , f [ j ][ i ] / f [ i ][ i ]); else del ( i , j , f [ i ][ i ] / f [ j ][ i ]); } if ( f [ j ][ i ]) ans = p - ans , swp ( i , j ); } ans = 1l l * ans * f [ i ][ i ] % p ; } return ans ; }","title":"\u8f97\u8f6c\u76f8\u9664\u6cd5"},{"location":"Math/Linear/gauss/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int n , flag1 = 1 , flag2 = 1 , f [ 501 ][ 501 ]; inline int Gauss () { int now = 1 ; for ( int i = 1 , pos = 0 ; i <= n ; ++ i , pos = 0 ) { for ( int j = now ; j <= n ; ++ j ) if ( f [ j ][ i ]) pos = j ; if ( ! pos ){ flag1 = 0 ; continue ;} for ( int j = 0 ; j <= n ; ++ j ) swap ( f [ pos ][ j ], f [ now ][ j ]); for ( int j = 1 ; j <= n ; ++ j ) { if ( j == now ) continue ; int rate = Cmul ( f [ j ][ i ], power ( f [ now ][ i ], MOD -2 )); for ( int k = 0 ; k <= n ; ++ k ) Mdel ( f [ j ][ k ], Cmul ( f [ now ][ k ], rate )); } ++ now ; } if ( now <= n ) { while ( now <= n ) if ( f [ now ++ ][ 0 ] != 0 ) return -1 ; return 0 ; } return 1 ; }","title":"\u9ad8\u65af\u6d88\u5143"},{"location":"Math/Linear/inv/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int n , f [ 410 ][ 810 ]; inline int INV () { for ( int i = 1 ; i <= n ; ++ i ) f [ i ][ i + n ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int pos = 0 ; for ( int j = i ; j <= n ; ++ j ) if ( f [ j ][ i ]){ pos = j ; break ;} if ( ! pos ) return 0 ; for ( int j = 1 ; j <= n * 2 ; ++ j ) swap ( f [ i ][ j ], f [ pos ][ j ]); int tmp = power ( f [ i ][ i ], MOD -2 ); for ( int j = 1 ; j <= n ; ++ j ) { if ( j == i ) continue ; int rate = Cmul ( f [ j ][ i ], tmp ); for ( int k = 1 ; k <= n * 2 ; ++ k ) Mdel ( f [ j ][ k ], Cmul ( f [ i ][ k ], rate )); } } for ( int i = 1 ; i <= n ; ++ i ) { int tmp = power ( f [ i ][ i ], MOD -2 ); for ( int j = n + 1 ; j <= n * 2 ; ++ j ) Mmul ( f [ i ][ j ], tmp ); } return 1 ; }","title":"\u77e9\u9635\u6c42\u9006"},{"location":"Math/numbertheory/BSGS/","text":"BSGS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 inline int power ( int a , int b , int p ) { int ans = 1 ; for (; b ; a = a * a % p , b >>= 1 ) if ( b & 1 ) ans = ans * a % p ; return ans ; } inline int BSGS ( int a , int b , int p ) { int t = sqrt ( p ) + 1 ; unordered_map < int , int > mp ; mp . clear (), b %= p ; for ( int j = 0 , now = b ; j < t ; now = now * a % p , ++ j ) mp [ now ] = j ; a = power ( a , t , p ); if ( ! a ) return b ? -1 : 1 ; for ( int i = 0 , now = 1 ; i <= t ; now = now * a % p , ++ i ) { int j = mp . find ( now ) == mp . end () ? -1 : mp [ now ]; if ( j >= 0 && i * t - j >= 0 ) return i * t - j ; } return -1 ; } exBSGS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 inline int power ( int a , int b , int p ) { int ans = 1 ; for (; b ; a = a * a % p , b >>= 1 ) if ( b & 1 ) ans = ans * a % p ; return ans ; } inline int BSGS ( int a , int b , int p ) { int t = sqrt ( p ) + 1 ; unordered_map < int , int > mp ; mp . clear (), b %= p ; for ( int j = 0 , now = b ; j < t ; now = now * a % p , ++ j ) mp [ now ] = j ; a = power ( a , t , p ); if ( ! a ) return b ? -1 : 1 ; for ( int i = 0 , now = 1 ; i <= t ; now = now * a % p , ++ i ) { int j = mp . find ( now ) == mp . end () ? -1 : mp [ now ]; if ( j >= 0 && i * t - j >= 0 ) return i * t - j ; } return -1 ; } void exgcd ( int a , int b , int & x , int & y ) { if ( ! b ) return x = 1 , y = 0 , void (); exgcd ( b , a % b , x , y ); int z = x ; x = y , y = z - x * ( a / b ); } int gcd ( int a , int b ){ return b ? gcd ( b , a % b ) : a ;} inline int inv ( int b , int p ){ int x , y ; exgcd ( b , p , x , y ), x = ( x % p + p ) % p ; return x ;} inline int exBSGS ( int a , int b , int p ) { b %= p ; if ( b == 1 || p == 1 ) return 0 ; int na = 1 , k = 0 , g = gcd ( a , p ); while ( g > 1 ) { if ( b % g != 0 ) return -1 ; ++ k , b /= g , p /= g , na = na * ( a / g ) % p , g = gcd ( a , p ); if ( na == b ) return k ; } int f = BSGS ( a , b * inv ( na , p ) % p , p ); if ( f == -1 ) return -1 ; return f + k ; }","title":"\u5927\u6b65\u5c0f\u6b65"},{"location":"Math/numbertheory/BSGS/#bsgs","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 inline int power ( int a , int b , int p ) { int ans = 1 ; for (; b ; a = a * a % p , b >>= 1 ) if ( b & 1 ) ans = ans * a % p ; return ans ; } inline int BSGS ( int a , int b , int p ) { int t = sqrt ( p ) + 1 ; unordered_map < int , int > mp ; mp . clear (), b %= p ; for ( int j = 0 , now = b ; j < t ; now = now * a % p , ++ j ) mp [ now ] = j ; a = power ( a , t , p ); if ( ! a ) return b ? -1 : 1 ; for ( int i = 0 , now = 1 ; i <= t ; now = now * a % p , ++ i ) { int j = mp . find ( now ) == mp . end () ? -1 : mp [ now ]; if ( j >= 0 && i * t - j >= 0 ) return i * t - j ; } return -1 ; }","title":"BSGS"},{"location":"Math/numbertheory/BSGS/#exbsgs","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 inline int power ( int a , int b , int p ) { int ans = 1 ; for (; b ; a = a * a % p , b >>= 1 ) if ( b & 1 ) ans = ans * a % p ; return ans ; } inline int BSGS ( int a , int b , int p ) { int t = sqrt ( p ) + 1 ; unordered_map < int , int > mp ; mp . clear (), b %= p ; for ( int j = 0 , now = b ; j < t ; now = now * a % p , ++ j ) mp [ now ] = j ; a = power ( a , t , p ); if ( ! a ) return b ? -1 : 1 ; for ( int i = 0 , now = 1 ; i <= t ; now = now * a % p , ++ i ) { int j = mp . find ( now ) == mp . end () ? -1 : mp [ now ]; if ( j >= 0 && i * t - j >= 0 ) return i * t - j ; } return -1 ; } void exgcd ( int a , int b , int & x , int & y ) { if ( ! b ) return x = 1 , y = 0 , void (); exgcd ( b , a % b , x , y ); int z = x ; x = y , y = z - x * ( a / b ); } int gcd ( int a , int b ){ return b ? gcd ( b , a % b ) : a ;} inline int inv ( int b , int p ){ int x , y ; exgcd ( b , p , x , y ), x = ( x % p + p ) % p ; return x ;} inline int exBSGS ( int a , int b , int p ) { b %= p ; if ( b == 1 || p == 1 ) return 0 ; int na = 1 , k = 0 , g = gcd ( a , p ); while ( g > 1 ) { if ( b % g != 0 ) return -1 ; ++ k , b /= g , p /= g , na = na * ( a / g ) % p , g = gcd ( a , p ); if ( na == b ) return k ; } int f = BSGS ( a , b * inv ( na , p ) % p , p ); if ( f == -1 ) return -1 ; return f + k ; }","title":"exBSGS"},{"location":"Math/numbertheory/CRT/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int exgcd ( int a , int b , int & x , int & y ) { if ( ! b ) return x = 1 , y = 0 , a ; int d = exgcd ( b , a % b , x , y ); int z = x ; x = y , y = z - x * ( a / b ); return d ; } int gcd ( int a , int b ){ return b ? gcd ( b , a % b ) : a ;} int m [ 100010 ], a [ 100010 ], n , M = 1 , x0 = 0 , MM , b , k , x , y ; inline int calc () { for ( int i = 1 ; i <= n ; ++ i ) { b = a [ i ] - x0 ; int d = exgcd ( M , m [ i ], k , y ); if ( b % d != 0 ){ write ( 114514 ); return ;} k = ( k * b / d % ( m [ i ] / d ) + m [ i ] / d ) % ( m [ i ] / d ), MM = M / gcd ( M , m [ i ]) * m [ i ]; x0 = (( x0 + k * M ) % MM + MM ) % MM , M = MM ; } return x0 ; }","title":"\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406"},{"location":"Math/numbertheory/gcd/","text":"Binary GCD 1 2 3 4 5 6 7 inline int gcd ( int a , int b ) { int az = __builtin_ctz ( a ), bz = __builtin_ctz ( b ); int z = min ( az , bz ), tmp ; b >>= bz ; while ( a ) a >>= az , tmp = a - b , az = __builtin_ctz ( tmp ), b = min ( a , b ), a = abs ( tmp ); return b << z ; } \u503c\u57df\u9884\u5904\u7406 GCD 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 bitset < 1000010 > v ; int cnt , ans , f [ 1000010 ][ 3 ], c [ 1010 ][ 1010 ], pr [ 300010 ]; inline int gcd ( int x , int y ) { int ans = 1 ; for ( int i = 0 ; i < 3 ; ++ i ) { int tmp = f [ x ][ i ] > 1000 ? y % f [ x ][ i ] ? 1 : f [ x ][ i ] : c [ f [ x ][ i ]][ y % f [ x ][ i ]]; y /= tmp , ans *= tmp ; } return ans ; } inline void mian () { f [ 1 ][ 0 ] = f [ 1 ][ 1 ] = f [ 1 ][ 2 ] = 1 ; for ( int i = 2 ; i <= 1000000 ; ++ i ) { if ( ! v [ i ]) pr [ ++ cnt ] = i , f [ i ][ 0 ] = f [ i ][ 1 ] = 1 , f [ i ][ 2 ] = i ; for ( int j = 1 ; j <= cnt && i * pr [ j ] <= 1000000 ; ++ j ) { v [ i * pr [ j ]] = 1 ; f [ i * pr [ j ]][ 0 ] = f [ i ][ 0 ] * pr [ j ]; f [ i * pr [ j ]][ 1 ] = f [ i ][ 1 ]; f [ i * pr [ j ]][ 2 ] = f [ i ][ 2 ]; sort ( f [ i * pr [ j ]], f [ i * pr [ j ]] + 3 ); if ( i % pr [ j ] == 0 ) break ; } } for ( int i = 1 ; i <= 1000 ; ++ i ) c [ i ][ 0 ] = c [ 0 ][ i ] = i ; for ( int i = 1 ; i <= 1000 ; ++ i ) for ( int j = 1 ; j <= i ; ++ j ) c [ i ][ j ] = c [ j ][ i ] = c [ j ][ i % j ]; }","title":"\u6700\u5927\u516c\u7ea6\u6570"},{"location":"Math/numbertheory/gcd/#binary-gcd","text":"1 2 3 4 5 6 7 inline int gcd ( int a , int b ) { int az = __builtin_ctz ( a ), bz = __builtin_ctz ( b ); int z = min ( az , bz ), tmp ; b >>= bz ; while ( a ) a >>= az , tmp = a - b , az = __builtin_ctz ( tmp ), b = min ( a , b ), a = abs ( tmp ); return b << z ; }","title":"Binary GCD"},{"location":"Math/numbertheory/gcd/#\u503c\u57df\u9884\u5904\u7406-gcd","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 bitset < 1000010 > v ; int cnt , ans , f [ 1000010 ][ 3 ], c [ 1010 ][ 1010 ], pr [ 300010 ]; inline int gcd ( int x , int y ) { int ans = 1 ; for ( int i = 0 ; i < 3 ; ++ i ) { int tmp = f [ x ][ i ] > 1000 ? y % f [ x ][ i ] ? 1 : f [ x ][ i ] : c [ f [ x ][ i ]][ y % f [ x ][ i ]]; y /= tmp , ans *= tmp ; } return ans ; } inline void mian () { f [ 1 ][ 0 ] = f [ 1 ][ 1 ] = f [ 1 ][ 2 ] = 1 ; for ( int i = 2 ; i <= 1000000 ; ++ i ) { if ( ! v [ i ]) pr [ ++ cnt ] = i , f [ i ][ 0 ] = f [ i ][ 1 ] = 1 , f [ i ][ 2 ] = i ; for ( int j = 1 ; j <= cnt && i * pr [ j ] <= 1000000 ; ++ j ) { v [ i * pr [ j ]] = 1 ; f [ i * pr [ j ]][ 0 ] = f [ i ][ 0 ] * pr [ j ]; f [ i * pr [ j ]][ 1 ] = f [ i ][ 1 ]; f [ i * pr [ j ]][ 2 ] = f [ i ][ 2 ]; sort ( f [ i * pr [ j ]], f [ i * pr [ j ]] + 3 ); if ( i % pr [ j ] == 0 ) break ; } } for ( int i = 1 ; i <= 1000 ; ++ i ) c [ i ][ 0 ] = c [ 0 ][ i ] = i ; for ( int i = 1 ; i <= 1000 ; ++ i ) for ( int j = 1 ; j <= i ; ++ j ) c [ i ][ j ] = c [ j ][ i ] = c [ j ][ i % j ]; }","title":"\u503c\u57df\u9884\u5904\u7406 GCD"},{"location":"Math/numbertheory/genshin/","text":"\u6ce8\u610f\u5148\u8c03\u7528 sieve() \u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 int T , n , d , m , cnt , pr [ 100010 ]; bitset < 2000010 > v ; vector < int > ve , ans ; int gcd ( int x , int y ){ return y ? gcd ( y , x % y ) : x ;} inline int power ( int x , int y , int z ) { int s = 1 ; for (; y ; y >>= 1 , x = 1l l * x * x % z ) if ( y & 1 ) s = 1l l * s * x % z ; return s ; } inline int phi ( int x ) { int y = x ; for ( int i = 2 ; i * i <= x ; ++ i ) { if ( x % i == 0 ) { y = y / i * ( i -1 ); while ( x % i == 0 ) x /= i ; } } if ( x != 1 ) y = y / x * ( x -1 ); return y ; } inline void sieve () { for ( int i = 2 ; i <= 1000000 ; ++ i ) { if ( ! v [ i ]) pr [ ++ cnt ] = i ; for ( int j = 1 ; j <= cnt && i * pr [ j ] <= 1000000 ; ++ j ) { v [ i * pr [ j ]] = 1 ; if ( i % pr [ j ] == 0 ) break ; } } v . reset (), v [ 2 ] = v [ 4 ] = 1 ; for ( int i = 2 ; i <= cnt ; ++ i ) { for ( ll j = pr [ i ]; j <= 1000000 ; j *= pr [ i ]) v [ j ] = 1 , v [ 2 * j ] = 1 ; } } inline vi calc ( int n ) { read ( n , d ), m = phi ( n ), ans . clear (), ve . clear (); int mm = m , g = 1 ; if ( ! v [ n ]) return ans ; for ( int i = 2 ; i * i <= m ; ++ i ) if ( m % i == 0 ){ ve . eb ( i ); while ( m % i == 0 ) m /= i ;} if ( m != 1 ) ve . eb ( m ); for (; g < n ; ++ g ) { if ( gcd ( g , n ) != 1 ) continue ; int fl = 1 ; for ( auto p : ve ) if ( power ( g , mm / p , n ) == 1 ){ fl = 0 ; break ;} if ( fl ) break ; } for ( int i = 1 , nw = g ; i <= mm ; ++ i , nw = 1l l * nw * g % n ) if ( gcd ( i , mm ) == 1 ) ans . eb ( nw ); return ans ; }","title":"\u539f\u6839"},{"location":"Math/numbertheory/lucas/","text":"Lucas \u5b9a\u7406 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 inline int power ( int x , int y ) { int s = 1 ; for (; y ; y >>= 1 , x = 1l l * x * x % p )) if ( y & 1 ) s = 1l l * s * x % p ; return s ; } inline int CC ( int n , int m ){ return n - m < 0 || n < 0 ? 0 : 1l l * fr [ n ] * inv [ m ] % p * inv [ n - m ] % p ;} inline int C ( int n , int m ) { if ( m == 0 ) return 1 ; return 1l l * C ( n / p , m / p ) * CC ( n % p , m % p ) % p ; } inline void init () { for ( int i = 1 ; i < p ; ++ i ) fr [ i ] = 1l l * fr [ i -1 ] * i % p ; inv [ p -1 ] = power ( fr [ p -1 ], p -2 ); for ( int i = p -2 ; i >= 1 ; -- i ) inv [ i ] = 1l l * inv [ i + 1 ] * ( i + 1 ) % p ; } exLucas \u5b9a\u7406 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 inline int power ( int x , int y , int p ) { int s = 1 ; for (; y ; y >>= 1 , x = x * x % p ) if ( y & 1 ) s = s * x % p ; return s ; } int exgcd ( int a , int b , int & x , int & y ) { if ( ! b ) return x = 1 , y = 0 , a ; int d = exgcd ( b , a % b , x , y ); int z = x ; x = y , y = z - x * ( a / b ); return d ; } inline int inv ( int x , int p ){ int X , Y ; return exgcd ( x , p , X , Y ),( X % p + p ) % p ;} int n , m , p , fr [ 1000001 ]; int f ( int k , int p , int P ){ if ( ! k ) return 1 ; return f ( k / p , p , P ) * power ( fr [ P ], k / P , P ) % P * fr [ k % P ] % P ;} int g ( int k , int p ) { int s = 0 , P = p ; for (; p <= k ; p = p * P ) s += k / p ; return s ; } int calc ( int p , int c ) { int P = power ( p , c , 1000000 ); fr [ 0 ] = 1 ; for ( int i = 1 ; i <= P ; ++ i ) i % p == 0 ? fr [ i ] = fr [ i -1 ] : fr [ i ] = fr [ i -1 ] * i % P ; int up = f ( n , p , P ), down = f ( m , p , P ) * f ( n - m , p , P ) % P , et = g ( n , p ) - g ( m , p ) - g ( n - m , p ); return up * inv ( down , P ) % P * power ( p , et , P ) % P ; } inline int calc () { int M = 1 , x0 = 0 ; for ( int i = 2 ; i * i <= p ; ++ i ) { if ( p % i == 0 ) { int s = 0 , t , d , p1 , X , Y ; for (; ! ( p % i ); p /= i , ++ s ); t = calc ( i , s ); p1 = power ( i , s , 1000000 ), t = (( calc ( i , s ) - x0 ) % p1 + p1 ) % p1 ; d = exgcd ( M , p1 , X , Y ), X = ( X % p1 + p1 ) % p1 ; X = t / d * X , x0 = ( x0 + M * X ) % ( M * p1 ), M = M * p1 ; } } if ( p != 1 ) { int s = 1 , i = p , t , d , p1 , X , Y ; p1 = power ( i , s , 1000000 ), t = (( calc ( i , s ) - x0 ) % p1 + p1 ) % p1 ; d = exgcd ( M , p1 , X , Y ), X = ( X % p1 + p1 ) % p1 ; X = t / d * X , x0 = ( x0 + M * X ) % ( M * p1 ), M = M * p1 ; } return x0 ; }","title":"Lucas \u5b9a\u7406"},{"location":"Math/numbertheory/lucas/#lucas-\u5b9a\u7406","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 inline int power ( int x , int y ) { int s = 1 ; for (; y ; y >>= 1 , x = 1l l * x * x % p )) if ( y & 1 ) s = 1l l * s * x % p ; return s ; } inline int CC ( int n , int m ){ return n - m < 0 || n < 0 ? 0 : 1l l * fr [ n ] * inv [ m ] % p * inv [ n - m ] % p ;} inline int C ( int n , int m ) { if ( m == 0 ) return 1 ; return 1l l * C ( n / p , m / p ) * CC ( n % p , m % p ) % p ; } inline void init () { for ( int i = 1 ; i < p ; ++ i ) fr [ i ] = 1l l * fr [ i -1 ] * i % p ; inv [ p -1 ] = power ( fr [ p -1 ], p -2 ); for ( int i = p -2 ; i >= 1 ; -- i ) inv [ i ] = 1l l * inv [ i + 1 ] * ( i + 1 ) % p ; }","title":"Lucas \u5b9a\u7406"},{"location":"Math/numbertheory/lucas/#exlucas-\u5b9a\u7406","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 inline int power ( int x , int y , int p ) { int s = 1 ; for (; y ; y >>= 1 , x = x * x % p ) if ( y & 1 ) s = s * x % p ; return s ; } int exgcd ( int a , int b , int & x , int & y ) { if ( ! b ) return x = 1 , y = 0 , a ; int d = exgcd ( b , a % b , x , y ); int z = x ; x = y , y = z - x * ( a / b ); return d ; } inline int inv ( int x , int p ){ int X , Y ; return exgcd ( x , p , X , Y ),( X % p + p ) % p ;} int n , m , p , fr [ 1000001 ]; int f ( int k , int p , int P ){ if ( ! k ) return 1 ; return f ( k / p , p , P ) * power ( fr [ P ], k / P , P ) % P * fr [ k % P ] % P ;} int g ( int k , int p ) { int s = 0 , P = p ; for (; p <= k ; p = p * P ) s += k / p ; return s ; } int calc ( int p , int c ) { int P = power ( p , c , 1000000 ); fr [ 0 ] = 1 ; for ( int i = 1 ; i <= P ; ++ i ) i % p == 0 ? fr [ i ] = fr [ i -1 ] : fr [ i ] = fr [ i -1 ] * i % P ; int up = f ( n , p , P ), down = f ( m , p , P ) * f ( n - m , p , P ) % P , et = g ( n , p ) - g ( m , p ) - g ( n - m , p ); return up * inv ( down , P ) % P * power ( p , et , P ) % P ; } inline int calc () { int M = 1 , x0 = 0 ; for ( int i = 2 ; i * i <= p ; ++ i ) { if ( p % i == 0 ) { int s = 0 , t , d , p1 , X , Y ; for (; ! ( p % i ); p /= i , ++ s ); t = calc ( i , s ); p1 = power ( i , s , 1000000 ), t = (( calc ( i , s ) - x0 ) % p1 + p1 ) % p1 ; d = exgcd ( M , p1 , X , Y ), X = ( X % p1 + p1 ) % p1 ; X = t / d * X , x0 = ( x0 + M * X ) % ( M * p1 ), M = M * p1 ; } } if ( p != 1 ) { int s = 1 , i = p , t , d , p1 , X , Y ; p1 = power ( i , s , 1000000 ), t = (( calc ( i , s ) - x0 ) % p1 + p1 ) % p1 ; d = exgcd ( M , p1 , X , Y ), X = ( X % p1 + p1 ) % p1 ; X = t / d * X , x0 = ( x0 + M * X ) % ( M * p1 ), M = M * p1 ; } return x0 ; }","title":"exLucas \u5b9a\u7406"},{"location":"Math/numbertheory/millerrabin/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 inline bool chk ( int n ) { if ( n < 3 || n % 2 == 0 ) return n == 2 ; int u = n -1 , t = 0 ; while ( u % 2 == 0 ) u /= 2 , ++ t ; for ( int i = 0 , s , a , v ; i < 8 ; ++ i ) { a = rd ( 2 , n -1 ), v = power ( a , u , n ); if ( v == 1 ) continue ; for ( s = 0 ; s < t ; ++ s ) { if ( v == n -1 ) break ; v = mul ( v , v , n ); } if ( s == t ) return 0 ; } return 1 ; }","title":"Miller-Rabin"},{"location":"Math/numbertheory/oper/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 int cnt , n , pr [ 2000010 ]; ui a [ 20000010 ], ans ; bitset < 20000010 > v ; inline void init () { for ( int i = 2 ; i <= 20000000 ; ++ i ) { if ( ! v [ i ]) pr [ ++ cnt ] = i ; for ( int j = 1 ; j <= cnt && i * pr [ j ] <= 20000000 ; ++ j ) { v [ i * pr [ j ]] = 1 ; if ( i % pr [ j ] == 0 ) break ; } } } inline void dirichlet () { for ( int i = 1 ; i <= cnt ; ++ i ) { for ( int j = 1 ; j * pr [ i ] <= 20000000 ; ++ j ) Madd ( a [ j * pr [ i ]], a [ j ]); } } inline void modius () { for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = i + i ; j <= n ; j += i ) Mdel ( a [ j ], a [ i ]); } }","title":"\u524d\u7f00\u548c\u4e0e\u53cd\u6f14"},{"location":"Math/numbertheory/pollardrho/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 mt19937_64 rnd ( time ( 0 ) ^ ( ull )( new char )); #define rd(l,r) ((l)+rnd()%((int)((r)-(l)+1))) inline int mul ( int x , int y , int z ) { int a = x * (( ld ) y / z ), b = x * y - a * z ; if ( b < 0 ) b += z ; if ( b >= z ) b -= z ; return b ; } inline int add ( int x , int y , int z ){ return x + y >= z ? x + y - z : x + y ;} inline int power ( int x , int y , int z ) { int s = 1 ; for (; y ; y >>= 1 , x = mul ( x , x , z )) if ( y & 1 ) s = mul ( s , x , z ); return s ; } inline bool chk ( int n ) { if ( n < 3 || n % 2 == 0 ) return n == 2 ; int u = n -1 , t = 0 ; while ( u % 2 == 0 ) u /= 2 , ++ t ; for ( int i = 0 , s , a , v ; i < 8 ; ++ i ) { a = rd ( 2 , n -1 ), v = power ( a , u , n ); if ( v == 1 ) continue ; for ( s = 0 ; s < t ; ++ s ) { if ( v == n -1 ) break ; v = mul ( v , v , n ); } if ( s == t ) return 0 ; } return 1 ; } #define nx(a) add(mul(a,a,n),c,n) inline int gcd ( int a , int b ) { int az = __builtin_ctzll ( a ), bz = __builtin_ctzll ( b ); int z = min ( az , bz ), tmp ; b >>= bz ; while ( a ) a >>= az , tmp = a - b , az = __builtin_ctzll ( tmp ), b = min ( a , b ), a = abs ( tmp ); return b << z ; } int calc ( int n ) { if ( n == 4 ) return 2 ; int x = rd ( 3 , n -1 ), y = x , c = rd ( 3 , n -1 ), d = 1 ; x = nx ( x ), y = nx ( nx ( y )); for ( int lim = 1 ; x != y ; lim = min ( 128l l , lim << 1 )) { int cnt = 1 ; for ( int i = 0 ; i < lim ; ++ i ) { int tmp = mul ( cnt , abs ( x - y ), n ); if ( ! tmp ) break ; cnt = tmp , x = nx ( x ), y = nx ( nx ( y )); } d = gcd ( cnt , n ); if ( d > 1 ) return d ; } return n ; } vi ve ; void dfs ( int n ) { if ( n == 1 ) return ; int d = calc ( n ), d2 ; while ( d == n ) d = calc ( n ); d2 = n / d ; if ( chk ( d )) ve . eb ( d ); else dfs ( d ); if ( chk ( d2 )) ve . eb ( d2 ); else dfs ( d2 ); }","title":"Pollard-Rho"},{"location":"Math/numbertheory/sieve/dusieve/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 unordered_map < int , ll > phi ; unordered_map < int , int > mu ; ll PHI [ 20000001 ]; int MU [ 20000001 ], prime [ 10000001 ], cnt , T , n ; bool v [ 20000001 ]; inline int read () { int ans = 0 ; char ch = getchar (); while (( ch > '9' ) || ( ch < '0' )) ch = getchar (); while (( ch >= '0' ) && ( ch <= '9' )) ans = ans * 10 + ch - '0' , ch = getchar (); return ans ; } ll askphi ( int k ) { if ( k <= 20000000 ) return PHI [ k ]; if ( phi [ k ]) return phi [ k ]; ll sum = k * ( k + 1 ) / 2 ; for ( int l = 2 , r ; l <= k ; l = r + 1 ) r = k / ( k / l ), sum -= ( r - l + 1 ) * askphi ( k / l ); return phi [ k ] = sum ; } int askmu ( int k ) { if ( k <= 20000000 ) return MU [ k ]; if ( mu [ k ]) return mu [ k ]; int sum = 1 ; for ( int l = 2 , r ; l <= k ; l = r + 1 ) r = k / ( k / l ), sum -= ( r - l + 1 ) * askmu ( k / l ); return mu [ k ] = sum ; } inline void sieve () { MU [ 1 ] = 1 , PHI [ 1 ] = 1 ; for ( int i = 2 ; i <= 20000000 ; ++ i ) { if ( ! v [ i ]) prime [ ++ cnt ] = i , PHI [ i ] = i -1 , MU [ i ] = -1 ; for ( int j = 1 ; j <= cnt ; ++ j ) { if ( i * prime [ j ] > 20000000 ) break ; v [ prime [ j ] * i ] = 1 ; if ( i % prime [ j ] == 0 ){ PHI [ i * prime [ j ]] = PHI [ i ] * prime [ j ], MU [ i * prime [ j ]] = 0 ; break ;} PHI [ prime [ j ] * i ] = PHI [ i ] * ( prime [ j ] -1 ), MU [ i * prime [ j ]] =- MU [ i ]; } PHI [ i ] += PHI [ i -1 ], MU [ i ] += MU [ i -1 ]; } }","title":"\u675c\u6559\u7b5b"},{"location":"Math/numbertheory/sieve/min25sieve/","text":"\u7b5b\u7684\u662f \\(f(p^k)=p^k(p^k-1)\\) \u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 ll n , w [ 300010 ], g1 [ 300010 ], g2 [ 300010 ], sum1 [ 300010 ], sum2 [ 300010 ], pr [ 300010 ]; int N , m , cnt , id1 [ 300010 ], id2 [ 300010 ], iv6 ; bool v [ 300010 ]; inline void preSieve () { for ( int i = 2 ; i <= N ; ++ i ) { if ( ! v [ i ]) pr [ ++ cnt ] = i ; for ( int j = 1 ; j <= cnt && pr [ j ] * i <= N ; ++ j ) { v [ pr [ j ] * i ] = 1 ; if ( i % pr [ j ] == 0 ) break ;} } for ( int i = 1 ; i <= cnt ; ++ i ) { sum1 [ i ] = Cadd ( sum1 [ i -1 ], pr [ i ]); sum2 [ i ] = ( sum2 [ i -1 ] + 1l l * pr [ i ] * pr [ i ]) % MOD ; } } inline int f1 ( ll x ){ x %= MOD ; return x * ( x + 1 ) / 2 % MOD ;} inline int f2 ( ll x ){ x %= MOD ; return x * ( x + 1 ) % MOD * ( 2 * x + 1 ) % MOD * iv6 % MOD ;} inline int getid ( ll x ){ return x <= N ? id1 [ x ] : id2 [ n / x ];} ll S ( ll x , int j ) { if ( pr [ j ] > x ) return 0 ; ll ans = Cdel ( Cdel ( g2 [ getid ( x )], g1 [ getid ( x )]), Cdel ( sum2 [ j ], sum1 [ j ])); for ( int i = j + 1 ; i <= cnt && pr [ i ] * pr [ j ] <= x ; ++ i ) { for ( ll e = 1 , sp = pr [ i ]; sp <= x ; sp *= pr [ i ], ++ e ) ans = ( ans + sp % MOD * ( sp % MOD -1 ) % MOD * ( S ( x / sp , i ) + ( e > 1 ))) % MOD ; } return ans ; } inline ll sieve () { N = sqrt ( n ), preSieve (), iv6 = power ( 6 , MOD -2 ); for ( ll l = 1 , r ; l <= n ; l = r + 1 ) { r = n / ( n / l ), w [ ++ m ] = n / l ; g1 [ m ] = f1 ( w [ m ]) -1 , g2 [ m ] = f2 ( w [ m ]) -1 ; if ( w [ m ] <= N ) id1 [ w [ m ]] = m ; else id2 [ n / w [ m ]] = m ; } for ( int i = 1 ; i <= cnt ; ++ i ) { for ( int j = 1 ; j <= m && pr [ i ] * pr [ i ] <= w [ j ]; ++ j ) { g1 [ j ] = (( g1 [ j ] -1ll * pr [ i ] * ( g1 [ getid ( w [ j ] / pr [ i ])] - sum1 [ i -1 ])) % MOD + MOD ) % MOD ; g2 [ j ] = (( g2 [ j ] -1ll * pr [ i ] * pr [ i ] % MOD * ( g2 [ getid ( w [ j ] / pr [ i ])] - sum2 [ i -1 ])) % MOD + MOD ) % MOD ; } } return S ( n , 0 ) + 1 ; }","title":"Min-25 \u7b5b"},{"location":"Math/poly/FWT/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 namespace FWT { #define count(i) __builtin_popcount(i) inline void OR ( vi & F , int opt = 1 ) { int n = F . size (); if ( opt == 1 ) for ( int i = 1 ; i < n ; i <<= 1 ) for ( int j = 0 ; j < n ; j += i << 1 ) for ( int k = j ; k < j + i ; ++ k ) Madd ( F [ k + i ], F [ k ]); else for ( int i = 1 ; i < n ; i <<= 1 ) for ( int j = 0 ; j < n ; j += i << 1 ) for ( int k = j ; k < j + i ; ++ k ) Mdel ( F [ k + i ], F [ k ]); } inline void AND ( vi & F , int opt = 1 ) { int n = F . size (); if ( opt == 1 ) for ( int i = 1 ; i < n ; i <<= 1 ) for ( int j = 0 ; j < n ; j += i << 1 ) for ( int k = j ; k < j + i ; ++ k ) Madd ( F [ k ], F [ k + i ]); else for ( int i = 1 ; i < n ; i <<= 1 ) for ( int j = 0 ; j < n ; j += i << 1 ) for ( int k = j ; k < j + i ; ++ k ) Mdel ( F [ k ], F [ k + i ]); } inline void XOR ( vi & F , int opt = 1 ) { int n = F . size (), x , y ; for ( int k = 1 ; k < n ; k <<= 1 ) for ( int i = 0 ; i < n ; i += k << 1 ) for ( int j = i ; j < i + k ; ++ j ) x = F [ j ], y = F [ j + k ], F [ j ] = Cadd ( x , y ), F [ j + k ] = Cdel ( x , y ); if ( opt == -1 ){ for ( int i = 0 , t = power ( n , MOD -2 ); i < n ; ++ i ) Mmul ( F [ i ], t );} } inline vi OR ( vi & F , vi & G ) { assert ( F . size () == G . size ()); OR ( F , 1 ), OR ( G , 1 ); vi H ( F . size ()); for ( int i = 0 ; i < ( int ) F . size (); ++ i ) H [ i ] = Cmul ( F [ i ], G [ i ]); return OR ( H , -1 ), H ; } inline vi AND ( vi & F , vi & G ) { assert ( F . size () == G . size ()); AND ( F , 1 ), AND ( G , 1 ); vi H ( F . size ()); for ( int i = 0 ; i < ( int ) F . size (); ++ i ) H [ i ] = Cmul ( F [ i ], G [ i ]); return AND ( H , -1 ), H ; } inline vi XOR ( vi & F , vi & G ) { assert ( F . size () == G . size ()); XOR ( F , 1 ), XOR ( G , 1 ); vi H ( F . size ()); for ( int i = 0 ; i < ( int ) F . size (); ++ i ) H [ i ] = Cmul ( F [ i ], G [ i ]); return XOR ( H , -1 ), H ; } inline vi MUL ( vi & F , vi & G ) { assert ( F . size () == G . size ()); static vi X [ 21 ], Y [ 21 ], Z [ 21 ], H ; int n = F . size (), m = __lg ( n ); for ( int i = 0 ; i <= m ; ++ i ) X [ i ] = vi ( n ), Y [ i ] = vi ( n ), Z [ i ] = vi ( n ); for ( int i = 0 ; i < n ; ++ i ) X [ count ( i )][ i ] = F [ i ]; for ( int i = 0 ; i < n ; ++ i ) Y [ count ( i )][ i ] = G [ i ]; for ( int i = 0 ; i <= m ; ++ i ) OR ( X [ i ], 1 ), OR ( Y [ i ], 1 ); for ( int x = 0 ; x <= m ; ++ x ) for ( int y = 0 ; x + y <= m ; ++ y ) for ( int i = 0 ; i < n ; ++ i ) Madd ( Z [ x + y ][ i ], Cmul ( X [ x ][ i ], Y [ y ][ i ])); for ( int i = 0 ; i <= m ; ++ i ) OR ( Z [ i ], -1 ); H . resize ( n ); for ( int i = 0 ; i < n ; ++ i ) H [ i ] = Z [ count ( i )][ i ]; return H ; } inline vi INV ( vi & F ) { int n = F . size (), m = __lg ( n ); static vi X [ 21 ], Y [ 21 ], G ; for ( int i = 0 ; i <= m ; ++ i ) X [ i ] = vi ( n ), Y [ i ] = vi ( n ); for ( int i = 0 ; i < n ; ++ i ) X [ count ( i )][ i ] = F [ i ]; for ( int i = 0 ; i <= m ; ++ i ) OR ( X [ i ], 1 ); for ( int i = 0 ; i < n ; ++ i ) { Y [ 0 ][ i ] = power ( X [ 0 ][ i ], MOD -2 ); for ( int j = 1 ; j <= m ; ++ j ) { for ( int k = 0 ; k < j ; ++ k ) Mdel ( Y [ j ][ i ], Cmul ( Y [ k ][ i ], X [ j - k ][ i ])); Mmul ( Y [ j ][ i ], Y [ 0 ][ i ]); } } for ( int i = 0 ; i <= m ; ++ i ) OR ( Y [ i ], -1 ); G . resize ( n ); for ( int i = 0 ; i < n ; ++ i ) G [ i ] = Y [ count ( i )][ i ]; return G ; } inline vi LN ( vi & F ) { int n = F . size (), m = __lg ( n ), iv [ 21 ]; static vi X [ 21 ], Y [ 21 ], G ; for ( int i = 0 ; i <= m ; ++ i ) X [ i ] = vi ( n ), Y [ i ] = vi ( n ), iv [ i ] = power ( i , MOD -2 ); for ( int i = 0 ; i < n ; ++ i ) X [ count ( i )][ i ] = F [ i ]; for ( int i = 0 ; i <= m ; ++ i ) OR ( X [ i ], 1 ); for ( int i = 0 ; i < n ; ++ i ) { Y [ 0 ][ i ] = power ( X [ 0 ][ i ], MOD -2 ); for ( int j = 1 ; j <= m ; ++ j ) { for ( int k = 0 ; k < j ; ++ k ) Mdel ( Y [ j ][ i ], Cmul ( Y [ k ][ i ], X [ j - k ][ i ])); Mmul ( Y [ j ][ i ], Y [ 0 ][ i ]); } for ( int k = m ; k >= 0 ; -- k ) { for ( int j = 1 ; j < m && j + k <= m ; ++ j ) Madd ( Y [ j + k ][ i ], Cmul ( X [ j + 1 ][ i ], j + 1 , Y [ k ][ i ])); Mmul ( Y [ k ][ i ], X [ 1 ][ i ]); } for ( int j = m ; j >= 1 ; -- j ) Y [ j ][ i ] = Cmul ( iv [ j ], Y [ j -1 ][ i ]); Y [ 0 ][ i ] = 0 ; } for ( int i = 0 ; i <= m ; ++ i ) OR ( Y [ i ], -1 ); G . resize ( n ); for ( int i = 0 ; i < n ; ++ i ) G [ i ] = Y [ count ( i )][ i ]; return G ; } inline vi EXP ( vi & F ) { int n = F . size (), m = __lg ( n ), iv [ 21 ]; static vi X [ 21 ], Y [ 21 ], G ; for ( int i = 0 ; i <= m ; ++ i ) X [ i ] = vi ( n ), Y [ i ] = vi ( n ), iv [ i ] = power ( i , MOD -2 ); for ( int i = 0 ; i < n ; ++ i ) X [ count ( i )][ i ] = F [ i ]; for ( int i = 0 ; i <= m ; ++ i ) OR ( X [ i ], 1 ); for ( int i = 0 ; i < n ; ++ i ) { Y [ 0 ][ i ] = 1 ; for ( int j = 0 ; j < m ; ++ j ) { for ( int k = 0 ; k <= j ; ++ k ) Madd ( Y [ j + 1 ][ i ], Cmul ( X [ k + 1 ][ i ], k + 1 , Y [ j - k ][ i ])); Mmul ( Y [ j + 1 ][ i ], iv [ j + 1 ]); } } for ( int i = 0 ; i <= m ; ++ i ) OR ( Y [ i ], -1 ); G . resize ( n ); for ( int i = 0 ; i < n ; ++ i ) G [ i ] = Y [ count ( i )][ i ]; return G ; } } using namespace FWT ;","title":"\u96c6\u5408\u5e42\u7ea7\u6570"},{"location":"Math/poly/interpolation/","text":"\u6c42\u591a\u9879\u5f0f\u7cfb\u6570\u8868\u793a\u6cd5\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int n , m , ans , x [ 2010 ], y [ 2010 ], d [ 2010 ], a [ 2010 ], b [ 2010 ]; inline void mian () { read ( n , m ), a [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { read ( x [ i ], y [ i ]); for ( int j = i ; j >= 1 ; -- j ) a [ j ] = Cdel ( a [ j -1 ], Cmul ( x [ i ], a [ j ])); Mmul ( a [ 0 ], MOD - x [ i ]); } for ( int i = 1 , v ; i <= n ; ++ i ) { int c = power ( MOD - x [ i ], MOD -2 ); v = 1 , b [ 0 ] = Cmul ( a [ 0 ], c ); for ( int j = 1 ; j < n ; ++ j ) b [ j ] = Cmul ( Cdel ( a [ j ], b [ j -1 ]), c ); for ( int j = 1 ; j <= n ; ++ j ) if ( i != j ) Mmul ( v , Cdel ( x [ i ], x [ j ])); v = Cmul ( y [ i ], power ( v , MOD -2 )); for ( int j = 0 ; j < n ; ++ j ) Madd ( d [ j ], Cmul ( v , b [ j ])); } for ( int j = 0 ; j < n ; ++ j ) Madd ( ans , Cmul ( power ( m , j ), d [ j ])); write ( ans ); } \u6c42\u70b9\u503c\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int n , k , ans , x [ 2001 ], y [ 2001 ]; inline void mian () { read ( n , k ); for ( int i = 1 ; i <= n ; ++ i ) read ( x [ i ], y [ i ]); for ( int i = 1 ; i <= n ; ++ i ) { int up = y [ i ], down = 1 ; for ( int j = 1 ; j <= n ; ++ j ) { if ( i == j ) continue ; Mmul ( up , k - x [ j ]), Mmul ( down , x [ i ] - x [ j ]); } Madd ( ans , Cmul ( up , power ( down , MOD -2 ))); } write ( ans ); }","title":"\u62c9\u683c\u6717\u65e5\u63d2\u503c"},{"location":"Math/poly/poly/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 namespace Poly { inline vi fix ( vi A , int n ){ return A . resize ( n ), A ;} const int MAXN = 2000000 ; int Shape , VBL , Invn [ MAXN ], R [ MAXN << 1 ], Prt [ MAXN << 1 ], P0 [ 50010 ], P1 [ 50010 ]; inline void init () { P0 [ 0 ] = P1 [ 0 ] = 1 , VBL = ceil ( sqrt ( MOD )), Invn [ 0 ] = 1 ; for ( int i = 1 ; i < MAXN ; ++ i ) Invn [ i ] = Cmul ( Invn [ i -1 ], i ); int tmp = power ( Invn [ MAXN -1 ], MOD -2 ); for ( int i = MAXN -1 ; i >= 1 ; -- i ) Invn [ i ] = Cmul ( tmp , Invn [ i -1 ]), Mmul ( tmp , i ); for ( int i = 1 ; i <= VBL ; ++ i ) P0 [ i ] = Cmul ( P0 [ i -1 ], Root ); for ( int i = 1 ; i <= VBL ; ++ i ) P1 [ i ] = Cmul ( P1 [ i -1 ], P0 [ VBL ]); } inline int powerr ( int x ){ return Cmul ( P0 [ x % VBL ], P1 [ x / VBL ]);} inline void NTT ( vi & A , int n , int opt ) { static ull B [ MAXN << 1 ], iv ; A . resize ( n ); for ( int i = 0 ; i < n ; ++ i ) B [ i ] = A [ R [ i ]]; for ( int mid = 1 ; mid < n ; mid <<= 1 ) { for ( int j = 0 ; j < n ; j += mid << 1 ) { for ( int k = j ; k < j + mid ; ++ k ) { ull x = B [ k ], y = Prt [ mid + k - j ] * B [ k + mid ] % MOD ; B [ k ] = x + y , B [ k + mid ] = x + MOD - y ; } } } if ( opt == 1 ) for ( int i = 0 ; i < n ; ++ i ) A [ i ] = B [ i ] % MOD ; else { reverse ( B + 1 , B + n ), iv = power ( n , MOD -2 ); for ( int i = 0 ; i < n ; ++ i ) A [ i ] = Cmul ( B [ i ] % MOD , iv ); } } inline void init ( int lim ) { if ( lim == Shape ) return ; int n = lim / 2 ; for ( int i = 0 ; i < lim ; ++ i ) R [ i ] = ( R [ i >> 1 ] >> 1 ) | (( i & 1 ) ? n : 0 ); for ( int i = 1 ; i < lim ; i <<= 1 ) { int wm = powerr (( MOD -1 ) / ( i << 1 )); Prt [ i ] = 1 ; for ( int j = 1 ; j < i ; ++ j ) Prt [ i + j ] = Cmul ( Prt [ i + j -1 ], wm ); } Shape = lim ; } inline vi der ( vi A ) { int N = A . size (); vi B ( N -1 ); for ( int i = 0 ; i < N -1 ; ++ i ) B [ i ] = Cmul ( i + 1 , A [ i + 1 ]); return B ; } inline vi inte ( vi A ) { int N = A . size (); vi B ( N + 1 ); for ( int i = 1 ; i <= N ; ++ i ) B [ i ] = Cmul ( A [ i -1 ], power ( i , MOD -2 )); return B ; } inline vi FFT ( vi A , vi B ) { int n = A . size (), m = B . size (), N = 1 ; while ( N <= n + m ) N <<= 1 ; init ( N ), NTT ( A , N , 1 ), NTT ( B , N , 1 ); for ( int i = 0 ; i < N ; ++ i ) A [ i ] = Cmul ( A [ i ], B [ i ]); return NTT ( A , N , 0 ), A . resize ( n + m -1 ), A ; } inline vi inv ( vi A ) { static vi B , TB , C ; B = {( int ) power ( A [ 0 ], MOD -2 )}; int N = A . size (); for ( int n = 1 ; n < N ; n <<= 1 ) { TB = B , C . clear (), C . resize ( n << 1 ); copy ( A . begin (), A . begin () + min ( N , 2 * n ), C . begin ()); init ( n << 1 ); NTT ( C , n << 1 , 1 ), NTT ( B , n << 1 , 1 ); for ( int i = 0 ; i < ( n << 1 ); ++ i ) Mmul ( C [ i ], B [ i ]); NTT ( C , n << 1 , 0 ); fill ( C . begin (), C . begin () + n , 0 ); NTT ( C , n << 1 , 1 ); for ( int i = 0 ; i < ( n << 1 ); ++ i ) Mmul ( B [ i ], MOD - C [ i ]); NTT ( B , n << 1 , 0 ); move ( TB . begin (), TB . end (), B . begin ()); } return B . resize ( N ), B ; } inline vi sqrt ( vi A ) { static vi G , F , TG , TF , TA ; int n = 1 , N = A . size (); G = { 1 }; for (; n < N ; n <<= 1 ) { TA . resize ( n << 1 ); TG = G , TG . resize ( n << 1 ); G . resize ( n ); copy ( A . begin (), A . begin () + min ( N , n ), TA . begin ()); init ( n << 1 ); NTT ( TA , n << 1 , 1 ), NTT ( TG , n << 1 , 1 ); for ( int i = 0 ; i < ( n << 1 ); ++ i ) TG [ i ] = Cdel ( TG [ i ], Cmul ( TA [ i ], TG [ i ], TG [ i ], TG [ i ])); NTT ( TG , n << 1 , 0 ); if ( n > 1 ) for ( int i = n >> 1 ; i < n ; ++ i ) G [ i ] = Cmul ( TG [ i ], inv2 ); } G . resize ( n ), F . resize ( n ), NTT ( G , n , 1 ); for ( int i = 0 ; i < n ; ++ i ) F [ i ] = Cmul ( G [ i ], TA [ i ]); NTT ( F , n , 0 ); for ( int i = n >> 1 ; i < n ; ++ i ) F [ i ] = 0 ; TF = F , NTT ( TF , n , 1 ); A . resize ( n ), NTT ( A , n , 1 ); for ( int i = 0 ; i < n ; ++ i ) TF [ i ] = Cmul ( G [ i ], Cdel ( A [ i ], Cmul ( TF [ i ], TF [ i ]))); NTT ( TF , n , 0 ); for ( int i = n >> 1 ; i < N ; ++ i ) F [ i ] = Cmul ( TF [ i ], inv2 ); return F . resize ( N ), F ; } inline vi ln ( vi A ) { int N = A . size (); A = FFT ( der ( A ), inv ( A )); return inte ( fix ( A , N -1 )); } inline vi exp ( vi A ) { static vi B , C , D , TB ; int N = A . size (); B = { 1 }; for ( int n = 1 ; n < N ; n <<= 1 ) { TB = C = B , C . resize ( n << 1 ), B . resize ( n << 1 ); D = ln ( B ), Mdel ( D [ 0 ], 1 ); for ( int i = 0 ; i < min ( n << 1 , N ); ++ i ) D [ i ] = Cdel ( A [ i ], D [ i ]); for ( int i = N ; i < ( n << 1 ); ++ i ) D [ i ] = MOD - D [ i ]; init ( n << 1 ), NTT ( D , n << 1 , 1 ), NTT ( C , n << 1 , 1 ); for ( int i = 0 ; i < ( n << 1 ); ++ i ) Mmul ( D [ i ], C [ i ]); NTT ( D , n << 1 , 0 ), B = D , copy ( TB . begin (), TB . end (), B . begin ()); } return B . resize ( N ), B ; } inline pair < vi , vi > div ( vi A , vi B ) { int n = A . size (), m = B . size (); static vi C , D ; reverse ( A . begin (), A . end ()); reverse ( B . begin (), B . end ()); D = FFT ( A , inv ( fix ( B , n - m + 1 ))), D . resize ( n - m + 1 ); reverse ( D . begin (), D . end ()); reverse ( A . begin (), A . end ()); reverse ( B . begin (), B . end ()); C = FFT ( B , D ); for ( int i = 0 ; i < m ; ++ i ) C [ i ] = Cdel ( A [ i ], C [ i ]); return mp ( D , fix ( C , m -1 )); } inline int bostan_mori ( vi P , vi Q , int n ) { vi rQ ; int N = 1 ; while ( N <= ( int ) P . size () * 2 ) N <<= 1 ; init ( N ); auto reduce = [ & ]( vi & A , int opt ) -> void { for ( int i = opt ; i < ( int ) A . size (); i += 2 ) A [ i >> 1 ] = A [ i ]; A . resize (( A . size () + 1 - opt ) >> 1 ); }; while ( n ) { rQ = Q ; for ( int i = 1 ; i < ( int ) Q . size (); i += 2 ) rQ [ i ] = Cdel ( 0 , rQ [ i ]); NTT ( rQ , N , 1 ), NTT ( P , N , 1 ), NTT ( Q , N , 1 ); for ( int i = 0 ; i < N ; ++ i ) Mmul ( P [ i ], rQ [ i ]), Mmul ( Q [ i ], rQ [ i ]); NTT ( P , N , 0 ), NTT ( Q , N , 0 ); reduce ( Q , 0 ), reduce ( P , n & 1 ); n >>= 1 ; } if ( P . empty ()) return 0 ; return Cmul ( P [ 0 ], power ( Q [ 0 ], MOD -2 )); } inline int CCHIR ( vi P , vi Q , int n ) { int m = Q . size (); Q . eb ( 0 ); for ( int j = m ; j ; -- j ) Q [ j ] = Q [ j -1 ]; Q [ 0 ] = MOD -1 ; return bostan_mori ( fix ( FFT ( P , Q ), m ), Q , n ); } inline vi BM ( vi A ) { vi lst , ans ; int p = -1 , delta = 0 ; for ( int i = 0 ; i < ( int ) A . size (); ++ i ) { int tmp = A [ i ]; for ( int j = 0 ; j < ( int ) ans . size (); ++ j ) Mdel ( tmp , Cmul ( A [ i -1 - j ], ans [ j ])); if ( ! tmp ) continue ; if ( p == -1 ) { p = i , delta = tmp ; ans . resize ( i + 1 ); continue ; } vi now = ans ; int mul = Cmul ( tmp , power ( delta , MOD -2 )); if (( int ) ans . size () < ( int ) lst . size () + i - p ) ans . resize (( int ) lst . size () + i - p ); Madd ( ans [ i - p -1 ], mul ); for ( int j = 0 ; j < ( int ) lst . size (); ++ j ) Mdel ( ans [ i - p + j ], Cmul ( mul , lst [ j ])); if (( int ) now . size () - i < ( int ) lst . size () - p ) lst = now , p = i , delta = tmp ; } return ans ; } vi IFFT ( vi F , vi G ) { int n = F . size (); reverse ( F . begin (), F . end ()); F = fix ( FFT ( F , G ), n ); reverse ( F . begin (), F . end ()); return F ; } vi _Q [ 400010 ], _iQ [ 400010 ]; vi MultiPoints ( vi F , vi X ) { int n = max ( F . size (), X . size ()), m = X . size (); F . resize ( n ), X . resize ( n ); vi ans ( n ); auto Prework = [ & ]( auto Prework , int id , int l , int r ) -> void { if ( l == r ) { _Q [ id ] = { 1 , Cdel ( 0 , X [ l ])}; return ; } int mid = ( l + r ) >> 1 ; Prework ( Prework , id << 1 , l , mid ); Prework ( Prework , id << 1 | 1 , mid + 1 , r ); int N = 1 ; while ( N <= r - l + 1 ) N <<= 1 ; init ( N ); _iQ [ id << 1 ] = _Q [ id << 1 ], NTT ( _iQ [ id << 1 ], N , 1 ); _iQ [ id << 1 | 1 ] = _Q [ id << 1 | 1 ], NTT ( _iQ [ id << 1 | 1 ], N , 1 ); _Q [ id ]. resize ( N ); for ( int i = 0 ; i < N ; ++ i ) _Q [ id ][ i ] = Cmul ( _iQ [ id << 1 ][ i ], _iQ [ id << 1 | 1 ][ i ]); NTT ( _Q [ id ], N , 0 ); }; auto solve = [ & ]( auto solve , int id , int l , int r , vi tmp ) -> void { tmp . resize ( r - l + 1 ); if ( l == r ) return ans [ l ] = tmp [ 0 ], void (); int mid = ( l + r ) >> 1 , N = 1 ; while ( N <= r - l + 1 ) N <<= 1 ; init ( N ); tmp . resize ( N ); reverse ( all ( tmp )); NTT ( tmp , N , 1 ); vi A ( N ), B ( N ); for ( int i = 0 ; i < N ; ++ i ) A [ i ] = Cmul ( tmp [ i ], _iQ [ id << 1 | 1 ][ i ]); for ( int i = 0 ; i < N ; ++ i ) B [ i ] = Cmul ( tmp [ i ], _iQ [ id << 1 ][ i ]); NTT ( A , N , 0 ), NTT ( B , N , 0 ); A . resize ( N ), B . resize ( N ); reverse ( all ( A )), reverse ( all ( B )); solve ( solve , id << 1 , l , mid , A ); solve ( solve , id << 1 | 1 , mid + 1 , r , B ); }; Prework ( Prework , 1 , 0 , n -1 ); solve ( solve , 1 , 0 , n -1 , IFFT ( F , inv ( _Q [ 1 ]))); ans . resize ( m ); return ans ; } vi _P [ 400010 ], _iP [ 400010 ]; vi InterPolate ( vi X , vi Y ) { int n = X . size (); auto Prework = [ & ]( auto Prework , int id , int l , int r ) -> void { if ( l == r ) return _iP [ id ] = _P [ id ] = { Cdel ( 0 , X [ l ]), 1 }, void (); int mid = ( l + r ) >> 1 , N = 1 ; Prework ( Prework , id << 1 , l , mid ); Prework ( Prework , id << 1 | 1 , mid + 1 , r ); while ( N <= r - l + 1 ) N <<= 1 ; init ( N ); NTT ( _iP [ id << 1 ], N , 1 ); NTT ( _iP [ id << 1 | 1 ], N , 1 ); _P [ id ]. resize ( N ); for ( int i = 0 ; i < N ; ++ i ) _P [ id ][ i ] = Cmul ( _iP [ id << 1 ][ i ], _iP [ id << 1 | 1 ][ i ]); NTT ( _P [ id ], N , 0 ); _P [ id ]. resize ( r - l + 2 ); _iP [ id ] = _P [ id ]; }; Prework ( Prework , 1 , 0 , n -1 ); vi D = MultiPoints ( der ( _P [ 1 ]), X ); auto solve = [ & ]( auto solve , int id , int l , int r ) -> vi { if ( l == r ) return { Cmul ( Y [ l ], power ( D [ l ], MOD -2 ))}; int mid = ( l + r ) >> 1 , N = 1 ; vi A = solve ( solve , id << 1 , l , mid ); vi B = solve ( solve , id << 1 | 1 , mid + 1 , r ); while ( N <= r - l + 1 ) N <<= 1 ; init ( N ); NTT ( A , N , 1 ), NTT ( B , N , 1 ); for ( int i = 0 ; i < N ; ++ i ) { Mmul ( A [ i ], _iP [ id << 1 | 1 ][ i ]); Mmul ( B [ i ], _iP [ id << 1 ][ i ]); } NTT ( A , N , 0 ), NTT ( B , N , 0 ); A . resize ( r - l + 1 ), B . resize ( r - l + 1 ); for ( int i = 0 ; i < r - l + 1 ; ++ i ) Madd ( A [ i ], B [ i ]); return A ; }; vi T = solve ( solve , 1 , 0 , n -1 ); return solve ( solve , 1 , 0 , n -1 ); } }","title":"\u591a\u9879\u5f0f"},{"location":"String/ACAM/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 const int N = 200000 ; int cnt = 1 , f [ N + 10 ], trie [ N + 10 ][ 26 ], fail [ N + 10 ], end [ N + 10 ]; queue < int > q ; inline void insert ( int id ) { int now = 1 ; for ( int i = 1 ; i <= len ; ++ i ) { if ( ! trie [ now ][ s [ i ] - 'a' ]) trie [ now ][ s [ i ] - 'a' ] =++ cnt ; now = trie [ now ][ s [ i ] - 'a' ]; } end [ id ] = now ; } inline void build () { q . e ( 1 ); for ( int i = 0 ; i < 26 ; ++ i ) trie [ 0 ][ i ] = 1 ; while ( ! q . empty ()) { int now = q . front (); q . pop (); for ( int i = 0 ; i < 26 ; ++ i ) { if ( trie [ now ][ i ]) { fail [ trie [ now ][ i ]] = trie [ fail [ now ]][ i ]; add ( trie [ fail [ now ]][ i ], trie [ now ][ i ]); q . e ( trie [ now ][ i ]); } else trie [ now ][ i ] = trie [ fail [ now ]][ i ]; } } }","title":"AC \u81ea\u52a8\u673a"},{"location":"String/GSAM/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int last , cnt = 1 , pos [ 1000010 ]; struct { int fa , len , ch [ 26 ];} t [ 2000010 ]; inline void add ( int x ) { int p = last , np , q , nq ; if (( q = t [ p ]. ch [ x ])) { if ( t [ q ]. len == t [ p ]. len + 1 ) return last = q , void (); t [ last = nq =++ cnt ] = t [ q ], t [ q ]. fa = nq , t [ nq ]. len = t [ p ]. len + 1 ; while ( t [ p ]. ch [ x ] == q ) t [ p ]. ch [ x ] = nq , p = t [ p ]. fa ; return ; } t [ last = np =++ cnt ]. len = t [ p ]. len + 1 ; while ( ! t [ p ]. ch [ x ]) t [ p ]. ch [ x ] = np , p = t [ p ]. fa ; if ( t [ q = t [ p ]. ch [ x ]]. len == t [ p ]. len + 1 ) return t [ np ]. fa = q , void (); t [ nq =++ cnt ] = t [ q ], t [ q ]. fa = t [ np ]. fa = nq , t [ nq ]. len = t [ p ]. len + 1 ; while ( t [ p ]. ch [ x ] == q ) t [ p ]. ch [ x ] = nq , p = t [ p ]. fa ; }","title":"\u5e7f\u4e49\u540e\u7f00\u81ea\u52a8\u673a"},{"location":"String/PAM/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 char s [ 500010 ]; struct PAM { int cnt , lst , L ; struct { int len , val , fa , ch [ 26 ];} t [ 1000010 ]; PAM (){ cnt = 1 , t [ 0 ]. fa = 1 , t [ 1 ]. len = -1 ;} inline int newnode ( int x ){ t [ ++ cnt ]. len = x ; return cnt ;} inline int get ( int x ){ while ( s [ L ] != s [ L - t [ x ]. len -1 ]) x = t [ x ]. fa ; return x ;} inline void ins ( int x ) { ++ L ; int p = get ( lst ), nw ; if ( ! t [ p ]. ch [ x ]) { nw = newnode ( t [ p ]. len + 2 ); t [ nw ]. fa = t [ get ( t [ p ]. fa )]. ch [ x ]; t [ p ]. ch [ x ] = nw ; t [ nw ]. val = t [ t [ nw ]. fa ]. val + 1 ; } else nw = t [ p ]. ch [ x ]; lst = nw ; } } t ;","title":"\u56de\u6587\u81ea\u52a8\u673a"},{"location":"String/SA/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 int n , maxn , m = 128 , F [ 21 ][ 1000001 ], sa [ 1000001 ], rk [ 1000001 ], b [ 1000001 ], x [ 1000001 ], y [ 1000001 ]; char s [ 250001 ]; inline int ask ( int x , int y ) { if ( x == y ) return inf ; if (( x = rk [ x ]) > ( y = rk [ y ])) swap ( x , y ); int k = __lg ( y - x ++ ); return min ( F [ k ][ x ], F [ k ][ y - ( 1 << k ) + 1 ]); } inline void SA () { scanf ( \"%s\" , s + 1 ), n = strlen ( s + 1 ); for ( int i = 1 ; i <= n ; ++ i ) ++ b [ x [ i ] = s [ i ]]; for ( int i = 2 ; i <= m ; ++ i ) b [ i ] += b [ i -1 ]; for ( int i = 1 ; i <= n ; ++ i ) sa [ b [ x [ i ]] -- ] = i ; for ( int k = 1 , num = 0 ; k <= n ; k <<= 1 , num = 0 ) { for ( int i = n - k + 1 ; i <= n ; ++ i ) y [ ++ num ] = i ; for ( int i = 1 ; i <= n ; ++ i ) if ( sa [ i ] > k ) y [ ++ num ] = sa [ i ] - k ; for ( int i = 1 ; i <= m ; ++ i ) b [ i ] = 0 ; for ( int i = 1 ; i <= n ; ++ i ) ++ b [ x [ i ]]; for ( int i = 2 ; i <= m ; ++ i ) b [ i ] += b [ i -1 ]; for ( int i = n ; i >= 1 ; -- i ) sa [ b [ x [ y [ i ]]] -- ] = y [ i ]; swap ( x , y ), x [ sa [ 1 ]] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) { if ( y [ sa [ i ]] == y [ sa [ i -1 ]] && y [ sa [ i ] + k ] == y [ sa [ i -1 ] + k ]) x [ sa [ i ]] = x [ sa [ i -1 ]]; else x [ sa [ i ]] = x [ sa [ i -1 ]] + 1 ; } if (( m = x [ sa [ n ]]) == n ) break ; } for ( int i = 1 ; i <= n ; ++ i ) rk [ sa [ i ]] = i ; for ( int i = 1 , k = 0 ; i <= n ; ++ i , k ?-- k : 0 ) { while ( s [ i + k ] == s [ sa [ rk [ i ] -1 ] + k ]) ++ k ; F [ 0 ][ rk [ i ]] = k ; } for ( int i = 1 ; i <= 20 ; ++ i ) { for ( int j = 1 ; j + ( 1 << i ) -1 <= n ; ++ j ) F [ i ][ j ] = min ( F [ i -1 ][ j ], F [ i -1 ][ j + ( 1 << ( i -1 ))]); } }","title":"\u540e\u7f00\u6570\u7ec4"},{"location":"String/SAM/","text":"1 2 3 4 5 6 7 8 9 10 11 int last = 1 , cnt = 1 ; struct { int ch [ 26 ], fa , len ;} t [ 2000010 ]; inline void add ( int x ) { int np =++ cnt , p = last , q , nq ; t [ last = np ]. len = t [ p ]. len + 1 , f [ np ] = 1 ; while ( p &&! t [ p ]. ch [ x ]) t [ p ]. ch [ x ] = np , p = t [ p ]. fa ; if ( ! p ) return t [ np ]. fa = 1 , void (); if ( t [ q = t [ p ]. ch [ x ]]. len == t [ p ]. len + 1 ) return t [ np ]. fa = q , void (); t [ nq =++ cnt ] = t [ q ], t [ nq ]. len = t [ p ]. len + 1 , t [ np ]. fa = t [ q ]. fa = nq ; while ( p && t [ p ]. ch [ x ] == q ) t [ p ]. ch [ x ] = nq , p = t [ p ]. fa ; }","title":"\u540e\u7f00\u81ea\u52a8\u673a"},{"location":"String/manacher/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const int N = 1000000 ; char s [ N + 10 ]; int n , f [ N + 10 ], g [ N + 10 ]; inline void manacher () { n = strlen ( s + 1 ); s [ 0 ] = '*' , s [ n + 1 ] = '#' ; for ( int i = 1 , p = 0 , r = 0 ; i <= n ; ++ i ) { if ( i <= r ) f [ i ] = min ( r - i + 1 , f [ 2 * p - i ]); while ( s [ i - f [ i ]] == s [ i + f [ i ]]) ++ f [ i ]; if ( Mmax ( r , i + f [ i ] -1 )) p = i ; } for ( int i = 1 , p = 0 , r = 0 ; i < n ; ++ i ) { if ( i <= r ) g [ i ] = min ( r - i , g [ 2 * p - i ]); while ( s [ i - g [ i ]] == s [ i + g [ i ] + 1 ]) ++ g [ i ]; if ( Mmax ( r , i + g [ i ])) p = i ; } }","title":"manacher"}]}